# dis.py
# Mathijs Saey
# DISc

# The MIT License (MIT)
#
# Copyright (c) 2013, 2014 Mathijs Saey
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

##
# \package backEnd.DVM.dis
# \brief dis writer
#
# This module contains an API that allows us to write
# DIS files. 
##

import StringIO

DVM_CHUNKS = 2

def createLink(srcChunk, srcInst, srcPort, dstChunk, dstInst, dstPort):
	return "LINK %d %d %d %d %d %d" % (
		srcChunk, srcInst, srcPort,
		dstChunk, dstInst, dstPort)

def createLiteral(inst, port, val):
	return "LITR %d %d %s" % (inst, port, val)

def createInstruction(type, key, args, comment = None):
		argStr = " ".join(map(str, args))

		if comment: 
			comment = "$ %s" % comment
		else: 
			comment = ""

		return "INST %s %d %s %s" % (type, key, argStr, comment)

def createChunk(idx):
	return "CHUNK %d" % idx

class DIS(object):
	def __init__(self, inputs, outputs):
		super(DIS, self).__init__()
		self.memory = [[] for i in xrange(0, DVM_CHUNKS)]
		self.addPredefined(inputs)

	def addPredefined(self, inputs):
		start = createInstruction('PB', 0, [inputs], "Entry point")
		stop  = createInstruction('PE', 1, [], "Exit point")
		self.add(start, 0)
		self.add(stop, 0)

	def add(self, str, chunk):
		key = (chunk, len(self.memory[chunk]))
		lst = self.memory[chunk]
		lst.append(str)
		return key

	def __repr__(self):
		buffer = StringIO.StringIO()
		buffer.write('$ Generated by DISc \n\n')

		for i in xrange(0, len(self.memory)):
			buffer.write(createChunk(i))
			buffer.write('\n')

			chunk = self.memory[i]
			for str in chunk:
				buffer.write(str)
				buffer.write('\n')

			buffer.write('\n')

		res = buffer.getvalue()
		buffer.close()
		return res