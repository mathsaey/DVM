<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Dataflow Software Stack: IF1</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Dataflow Software Stack
   &#160;<span id="projectnumber">032db78</span>
   </div>
   <div id="projectbrief">Master Thesis of Mathijs Saey at the VUB</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">IF1 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Concepts">IF1 Concepts</a></li>
<li class="level1"><a href="#Form">IF1 Instructions</a><ul><li class="level2"><a href="#types">Labels and Types</a></li>
</ul>
</li>
<li class="level1"><a href="#Comments">Appendix A: Comments</a><ul><li class="level2"><a href="#Stamps">Stamps</a></li>
<li class="level2"><a href="#Pragmas">Pragmas</a></li>
</ul>
</li>
<li class="level1"><a href="#Literal_def">Appendix B: Literal Definitions</a></li>
<li class="level1"><a href="#Nodes">Appendix C: Nodes</a><ul><li class="level2"><a href="#Nodes_Simple">Simple nodes</a></li>
<li class="level2"><a href="#Nodes_Comound">Compound Nodes</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1>IF1 Quick Reference</h1>
<p>This page serves as a basic introduction to the IF1 language. The information on this page is based on the paper: <code>IF1 - An Intermediate Form for Applicative Languages. (Stephen Skedzielewski 1985)</code></p>
<p>On this page, we attempt to create a compact yet complete overview of the language that should be enough to write an if1 parser without any previous IF1 knowledge.</p>
<p>A few IF1 and Sisal examples are present in the repository, a copy of these examples is also present in the documentation:</p><ul>
<li><a href="_Simple.html">Simple piece of Sisal/IF1 code</a></li>
<li><a href="_Call.html">Simple call in Sisal/IF1</a></li>
<li><a href="_Select.html">Select compound node in Sisal/IF1</a></li>
<li><a href="_Sort.html">Sorting algorithm in Sisal/IF1</a></li>
</ul>
<h1><a class="anchor" id="Concepts"></a>
IF1 Concepts</h1>
<p>IF1 represents directed, acyclic graphs, these graphs have a few components.</p>
<ul>
<li>IF1 nodes are operations.<ul>
<li>a node can have an arbitrary amount of in -and outputs.</li>
<li>IF1 defines over 50 nodes, that is, "native" operations.</li>
<li>The in -and output of a node happens through <b>ports</b>, which are numbered indicators of in and output locations</li>
<li>Port indexing starts from 1</li>
<li>Not every node has a predefined amount of ports.</li>
</ul>
</li>
<li>Edges represent data paths between nodes.<ul>
<li>Edges carry <b>type information</b><ul>
<li>Not mandatory</li>
<li>Can describe user-defined types and built-in types.</li>
</ul>
</li>
<li>A special edge exists to describe literal constants.<ul>
<li>Don't contain a source port</li>
<li>Contain the value of a literal as a string.</li>
</ul>
</li>
</ul>
</li>
<li>Graph boundaries surround groups of nodes and edges.</li>
</ul>
<h1><a class="anchor" id="Form"></a>
IF1 Instructions</h1>
<p>IF1 instructions are delimited by newlines. The first character after a newline determines the type of instruction the line represents, the rest of the line consists of a number of whitespace separated fields, the amount of which depends on that specific instruction. Any extra text listed after the fields is considered to be a comment, so are lines that start with C. For more information about comments, look into <a href="#Comments">appendix A</a>.</p>
<p>The following table lists the different instructions types.</p>
<table class="doxtable">
<tr>
<th>Character </th><th>Represents </th><th>Syntax  </th></tr>
<tr>
<td>T </td><td>type </td><td><code>T label type_code arg_1 arg_2</code> </td></tr>
<tr>
<td>E </td><td>edge </td><td><code>E source_node port destination_node port type</code> </td></tr>
<tr>
<td>L </td><td>literal </td><td><code>L destination_node port type string</code> </td></tr>
<tr>
<td>G </td><td>subgraph of a compound node </td><td><code>G type_reference</code> </td></tr>
<tr>
<td>G </td><td>local function graph </td><td><code>G type_reference "name"</code> </td></tr>
<tr>
<td>X </td><td>global function graph </td><td><code>X type_reference "name"</code> </td></tr>
<tr>
<td>I </td><td>imported function </td><td><code>I type_reference "name"</code> </td></tr>
<tr>
<td>N </td><td>simple node </td><td><code>N label operation</code> </td></tr>
<tr>
<td>{ </td><td>start compound node </td><td><code>{ Compound label operation</code> </td></tr>
<tr>
<td>} </td><td>end compound node </td><td><code>} label operation association_list_length association_list_element_1 association_list_element_2 ...</code> </td></tr>
</table>
<p>The semantics of these instructions are explained below, explanation about <em>labels</em> and <em>types</em> are presented in the <a href="#types">labels and types</a> section.</p>
<ul>
<li>Simple nodes simply contain a label and an identifier, this identifier represents a native IF1 instruction.</li>
<li>Compound nodes contain subgraphs and represent more complex operations, such as a for loop.</li>
<li>The compound node contains a few subgraphs that represent parts of the compound node, such as the initialization and the condition check, the association list shows which subgraphs represent which action.</li>
<li>Graph boundaries represent a function and simply contain the type (check out the function type) and name of this function.</li>
<li>Graph boundaries have a scope associated with them, anything below the boundary declaration is part of the graph's scope until either a "}, G,X or I" is encountered.</li>
<li>Subgraphs in compound nodes are not required to give a type.</li>
<li>Edges simply contain the input node, and the port on this node, the destination node, and the port on this node that this edge leads to. Furthermore, the edge also contains the type of it's data.</li>
<li>Literals contain their destination, the port on this destination, their type and a string version of their counts. <a href="ref #Literal_def">Appendix B</a> contains an overview of some of the most common literals.</li>
</ul>
<h2><a class="anchor" id="types"></a>
Labels and Types</h2>
<p>IF1 instructions commonly contain a type identifier, the purpose of this section is to explain IF1 type definitions, any defined type is referred to by it's <em>label</em>.</p>
<p>Labels are represented by integers, and are used to identify nodes and types. Nodes and types do not share labels, that is, a node and a type may have the same integer as label without being related in any way. Type labels share a global scope, while Node labels only have to be unique within their enclosing graph. It's also worth noting that a missing or unknown type is referred to by using the label 0.</p>
<p>With that being said, we can look at the type definitions: </p><pre class="fragment">T label type_code arg_1 arg_2
</pre><ul>
<li>Label can be used to refer to the type later on.</li>
<li>The type code can be considered to be an argument that indicates what type of type we are dealing with. This code can be seen as a constructor for that type.</li>
<li>The exact use of the other codes depends on the type_code. They can be seen as the arguments to a type constructor.</li>
</ul>
<p>To clarify this, let's look at a basic sisal type. In this case, the boolean.</p>
<p><code>T 1 1 0 na=Boolean</code></p>
<ul>
<li>T implies that we are declaring a type</li>
<li>1 is the <em>label</em> of the type, it will be used to refer to the type we are constructing from now on.</li>
<li>1 is the <em>type_code</em> of the type. This particular type code tells us that we are dealing with a <em>basic code</em>.</li>
<li>From the information of the type_code, we know that 0 is a basic code, in this case the basic code 0 represents a boolean.</li>
<li>The rest of the line is a comment, it tells us we are dealing with a boolean.</li>
</ul>
<p>What follows is a table of the possible type codes and their meaning.</p>
<table class="doxtable">
<tr>
<th>Code </th><th>Type </th><th>Argument 1 </th><th>Argument 2  </th></tr>
<tr>
<td>0 </td><td>Array </td><td>Base type </td><td><code>none</code> </td></tr>
<tr>
<td>1 </td><td>Basic code </td><td>Basic code </td><td><code>none</code> </td></tr>
<tr>
<td>2 </td><td>Field </td><td>Field type </td><td>Next field </td></tr>
<tr>
<td>3 </td><td>Function </td><td>Argument type </td><td>Result type </td></tr>
<tr>
<td>4 </td><td>Multiple </td><td>Base type </td><td><code>none</code> </td></tr>
<tr>
<td>5 </td><td>Record </td><td>First field </td><td><code>none</code> </td></tr>
<tr>
<td>6 </td><td>Stream </td><td>Base type </td><td><code>none</code> </td></tr>
<tr>
<td>7 </td><td>Tag </td><td>Tag type </td><td>Next tag </td></tr>
<tr>
<td>8 </td><td>Tuple </td><td>Type </td><td>Next in tuple </td></tr>
<tr>
<td>9 </td><td>Union </td><td>First Tag </td><td><code>none</code> </td></tr>
</table>
<p>In the following sections, the different types are described.</p>
<h4>Basic types</h4>
<p>As the example in the parent section indicates, basic types simply indicate a standard type, the argument is simply a code that tells us which type we are dealing with. A table with the basic types and their code can be found below.</p>
<table class="doxtable">
<tr>
<th>Code </th><th>Type  </th></tr>
<tr>
<td>0 </td><td>Boolean </td></tr>
<tr>
<td>1 </td><td>Character </td></tr>
<tr>
<td>2 </td><td>Double </td></tr>
<tr>
<td>3 </td><td>Integer </td></tr>
<tr>
<td>4 </td><td>Null </td></tr>
<tr>
<td>5 </td><td>Real </td></tr>
<tr>
<td>6 </td><td>WildBasic* </td></tr>
</table>
<p>`* This type does not appear in the official reference, but is generated by sisalc 14.1.</p>
<h4>Array and Streams</h4>
<p>Arrays and streams simply point to the <em>label</em> of the type they contain.</p>
<h4>Records and fields, unions and tags. And tuples.</h4>
<p>A record can be seen as a pointer to a field. It simply contains it's label, the type_code that indicates it's a record and the <em>label</em> of it's first field.</p>
<p>A field contains it's label, it's type_code, the <em>label</em> of the type it contains, and the <em>label</em> of the next field. The last field contains 0 as the <em>label</em> that points to the next field.</p>
<p>Unions and tags work in the same way, the only difference is that unions can be seen as a pointer to a tag. A tag points to the next tag like a field points to the next field.</p>
<p>Tuples follow the same contain your own type, point to the next one convention, but don't require an initial pointer.</p>
<h4>Functions</h4>
<p>A function type simple contains "pointers" to 2 tuples, the first tuple represents the arguments this function accepts while the second tuple represents the result it returns.</p>
<p>In terms of higher level languages, the function type simple declares the function's signature, without the name.</p>
<h1><a class="anchor" id="Comments"></a>
Appendix A: Comments</h1>
<p>2 main types of comments exist in IF1, stamps and pragmas, stamps are comments that occupy an entire line that starts with <code>C$</code>, pragmas are comments that are added after the fields of a line.</p>
<h2><a class="anchor" id="Stamps"></a>
Stamps</h2>
<p>Stamps are used to mark some processing that has been done to a file, a few stamp type exists. A stamp line has the following syntax: <code>C$ stamp_type info</code>. The following table provides an overview of the different stamp types.</p>
<table class="doxtable">
<tr>
<th>Character </th><th>Meaning  </th></tr>
<tr>
<td>A </td><td>Array update analysis </td></tr>
<tr>
<td>C </td><td>Structure checker </td></tr>
<tr>
<td>D </td><td>Order nodes using data dependencies </td></tr>
<tr>
<td>E </td><td>Common subexpression information </td></tr>
<tr>
<td>F </td><td>Frontend </td></tr>
<tr>
<td>L </td><td>Loop invariant removal </td></tr>
<tr>
<td>O </td><td>Add offsets for use by the interpreter </td></tr>
<tr>
<td>P </td><td>Partitioning analysis </td></tr>
<tr>
<td>S </td><td>Stream analysis </td></tr>
<tr>
<td>V </td><td>Vector analysis </td></tr>
</table>
<h2><a class="anchor" id="Pragmas"></a>
Pragmas</h2>
<p>Pragmas are used to add additional information to an instruction. Currently, 2 types of pragmas exist, pragmas that are generated by the compiler, and pragmas that are added after analyzing. Multiple pragmas can be added after a single instruction. Pragmas are terminated by a whitespace character.</p>
<p>Pragmas have the following syntax: <code>%&lt;id&gt;=&lt;anything&gt;,&lt;otheranything&gt; %&lt;otherid&gt;=&lt;anything&gt;</code></p>
<p>The following table provides an overview of the meaning of different pragmas. The type column indicates the type of pragma; C indicates a compiler-generated pragma, while A indicates a pragma generated by analyzing.</p>
<table class="doxtable">
<tr>
<th>Character </th><th>Type </th><th>Meaning  </th></tr>
<tr>
<td>bd </td><td>C </td><td>bounds </td></tr>
<tr>
<td>na </td><td>C </td><td>name </td></tr>
<tr>
<td>sl </td><td>C </td><td>source line </td></tr>
<tr>
<td>op </td><td>C </td><td>op number with line of source </td></tr>
<tr>
<td>ar </td><td>A </td><td>size of activation record needed </td></tr>
<tr>
<td>lz </td><td>A </td><td>edge carries a value that must be demanded </td></tr>
<tr>
<td>mk </td><td>A </td><td>mark this edge by reference (mk=r) or by value (mk=v) </td></tr>
<tr>
<td>of </td><td>A </td><td>offset in activation record </td></tr>
<tr>
<td>st </td><td>A </td><td>style of memory allocation (st=p for pointer, st=c for contiguous) </td></tr>
<tr>
<td>xy </td><td>A </td><td>position for node in graphic output </td></tr>
</table>
<h1><a class="anchor" id="Literal_def"></a>
Appendix B: Literal Definitions</h1>
<table class="doxtable">
<tr>
<th>Type </th><th>String  </th></tr>
<tr>
<td>Function names </td><td>"someName" </td></tr>
<tr>
<td>Boolean values </td><td>"T" or "F" </td></tr>
<tr>
<td>Integer values </td><td>"03349" </td></tr>
<tr>
<td>Characters </td><td>"'\n'" or "'x'" </td></tr>
<tr>
<td>Null value </td><td>nil </td></tr>
<tr>
<td>Single-precision floating point value </td><td>"3.503" or "5e3" or ".503" </td></tr>
<tr>
<td>Double-precision floating point value </td><td>"6.626198d-34" ".056D24" </td></tr>
</table>
<h1><a class="anchor" id="Nodes"></a>
Appendix C: Nodes</h1>
<p>The next section desribes both the simple and compound nodes that IF1 predefines, a few datatype conventions should be established for this.</p>
<ul>
<li><em>arith</em> types correspond to any numeric type</li>
<li><em>algeb</em> types correspond to arith types and booleans</li>
<li><em>atom</em> types correspond to algeb types and characters</li>
<li><em>T</em> corresponds to any type</li>
<li><code>(T)+</code> Represents one or more occurence of T</li>
<li><code>(T)*</code> Represents zero or more occurence of T</li>
<li><code>[T]</code> Represents one or zero occurence of T</li>
<li><code>AS(T)</code> Represents an array or a stream that contains type T.</li>
<li><code>ASM(T)</code> Represents an array,stream or multiple that contains type T.</li>
</ul>
<h2><a class="anchor" id="Nodes_Simple"></a>
Simple nodes</h2>
<table class="doxtable">
<tr>
<th>Label </th><th>Name </th><th>Input </th><th>Output </th><th>Operation  </th></tr>
<tr>
<td>100 </td><td>AAddH </td><td><code>AS(T) x T</code> </td><td><code>AS(T)</code> </td><td>Add an element to the back of the array/stream </td></tr>
<tr>
<td>101 </td><td>AAddL </td><td><code>AS(T) x T</code> </td><td><code>AS(T)</code> </td><td>Add an element to the front of the array/stream </td></tr>
<tr>
<td>102 </td><td>AAdjust </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>103 </td><td>ABuild </td><td><code>Int x (T)*</code> </td><td><code>AS(T)</code> </td><td>Create an array/stream with a lower bound, following arguments are elements of the array </td></tr>
<tr>
<td>104 </td><td>ACatenate </td><td><code>AS(T) x (AS(T))+</code> </td><td><code>Array(T)</code> </td><td>Catenate arrays/streams. </td></tr>
<tr>
<td>105 </td><td>AElement </td><td><code>AS(T) x Int</code> </td><td><code>T</code> </td><td>Returns element at a given index. </td></tr>
<tr>
<td>106 </td><td>AFill </td><td><code>Int x Int x T</code> </td><td><code>AS(T)</code> </td><td>Create an array/stream with a lower and upper bound and fill it with the last argument.<br />
 An empty array/stream is created if the lower bound &gt; upper bound </td></tr>
<tr>
<td>107 </td><td>AGather </td><td><code>Int x Mult(T) x [Mult(T)]</code> </td><td><code>AS(T)</code> </td><td><b>Only used in return subgraph</b> <br />
Creates an array or stream with the values of the 2nd argument, <br />
if the corresponding 3rd argument is true (or not given <br />
The first argument represents the lower bound of the array. </td></tr>
<tr>
<td>108 </td><td>AIsEmpty </td><td><code>AS(T)</code> </td><td><code>Bool</code> </td><td>Returns True if the array/stream is empty </td></tr>
<tr>
<td>109 </td><td>ALimH </td><td><code>AS(T)</code> </td><td><code>Int</code> </td><td>upper bound of array/stream </td></tr>
<tr>
<td>110 </td><td>ALimL </td><td><code>AS(T)</code> </td><td><code>Int</code> </td><td>lower bound of array/stream (always 1 in case of a stream) </td></tr>
<tr>
<td>111 </td><td>ARemH </td><td><code>ASM(T)</code> </td><td><code>ASM(T)</code> </td><td>Remove last element, returns error if empty </td></tr>
<tr>
<td>112 </td><td>ARemL </td><td><code>ASM(T)</code> </td><td><code>ASM(T)</code> </td><td>Remove first element, returns error if empty </td></tr>
<tr>
<td>113 </td><td>AReplace </td><td><code>Array(T) x Int x (T)+</code> </td><td><code>Array(T)</code> </td><td>Returns a new array with with the given value at the given idx of the old array. <br />
 If multiple values are provided, they are placed consecutively </td></tr>
<tr>
<td>114 </td><td>AScatter </td><td><code>AS(T)</code> </td><td><code>Multiple(T) x Multiple(Int)</code> </td><td><b>Only appears in generator of forall nodes</b> <br />
Places array at port one, and the indices of this array at port 2. </td></tr>
<tr>
<td>115 </td><td>ASetL </td><td><code>Array(T) x Int</code> </td><td><code>Array(T)</code> </td><td>Shifts the lower index of the array, all indices are shifted to reflect this </td></tr>
<tr>
<td>116 </td><td>ASize </td><td><code>AS(T)</code> </td><td><code>Int</code> </td><td>Returns the amount of elements in the highest dimension of the stream/array </td></tr>
<tr>
<td>117 </td><td>Abs </td><td><code>Arith</code> </td><td><code>Arith</code> </td><td>Absolute value </td></tr>
<tr>
<td>118 </td><td>BindArguments </td><td><code>Func x (T)*</code> </td><td><code>Func</code> </td><td>Returns a new function with the given arguments bound to it. </td></tr>
<tr>
<td>119 </td><td>Bool </td><td><code>Int</code> </td><td><code>Bool</code> </td><td>0 =&gt; false, 1 =&gt; true, anything else =&gt; error </td></tr>
<tr>
<td>120 </td><td>Call </td><td><code>Func x (T)*</code> </td><td><code>(T)+</code> </td><td>Call a function (function is represented as literal) </td></tr>
<tr>
<td>121 </td><td>Char </td><td><code>Int</code> </td><td><code>Char</code> </td><td>Maps to the appropriate error value (or to an error) </td></tr>
<tr>
<td>122 </td><td>Div </td><td><code>Arith x Arith</code> </td><td><code>Arith</code> </td><td>Division, when applied to integer, round to integer. </td></tr>
<tr>
<td>123 </td><td>Double </td><td><code>Real OR Int</code> </td><td><code>Double</code> </td><td>Converts to double, returns an error if the value cannot be represented as a double </td></tr>
<tr>
<td>124 </td><td>Equal </td><td><code>Atom x Atom</code> </td><td><code>Boolean</code> </td><td><code>==</code> </td></tr>
<tr>
<td>125 </td><td>Exp </td><td><code>Arith x Arith</code> </td><td><code>Arith</code> </td><td><code>exp(x,y) = x^y</code> May lead to errors depending on input </td></tr>
<tr>
<td>126 </td><td>FirstValue </td><td><code>Mult(T) x [Mult(Bool)]</code> </td><td><code>T</code> </td><td><b>Only used in return subgraph</b> <br />
Returns the first value for which the corresponding bool is true (if present) </td></tr>
<tr>
<td>127 </td><td>FinalValue </td><td><code>Mult(T) x [Mult(Bool)]</code> </td><td><code>T</code> </td><td><b>Only used in return subgraph</b> <br />
Returns the last value for which the corresponding bool is true (if present) </td></tr>
<tr>
<td>128 </td><td>Floor </td><td><code>Real OR Double</code> </td><td><code>Int</code> </td><td>Rounds down, returns error if the result is not in the integer range. </td></tr>
<tr>
<td>129 </td><td>Int </td><td><code>Atom</code> </td><td><code>Int</code> </td><td>Real or double get rounded (floor after adding 0,5). Charachters returns the matching ASCII code. <br />
False maps to 0, True maps to 1. <br />
Returns an error if the value is out of the integer range. </td></tr>
<tr>
<td>130 </td><td>IsError </td><td><code>T x T</code> </td><td><code>Boolean</code> </td><td>Returns true if the second error has the same value as the first (string literal). <br />
If the first value is the special <em>error</em> value, this function should match any error value. </td></tr>
<tr>
<td>131 </td><td>Less </td><td><code>Atom x Atom</code> </td><td><code>Boolean</code> </td><td><code>&lt;</code> Both inputs should be of the same type </td></tr>
<tr>
<td>132 </td><td>LessEqual </td><td><code>Atom x Atom</code> </td><td><code>Boolean</code> </td><td><code>=&lt;</code> Both inputs should be of the same type. Also represents boolean implication </td></tr>
<tr>
<td>133 </td><td>Max </td><td><code>Algeb x Algeb</code> </td><td><code>Algeb</code> </td><td>Maximum when used on <em>arith</em> types, <em>or</em> when used on boolean types </td></tr>
<tr>
<td>134 </td><td>Min </td><td><code>Algeb x Algeb</code> </td><td><code>Algeb</code> </td><td>Minimum when used on <em>arith</em> types, <em>and</em> when used on boolean types </td></tr>
<tr>
<td>135 </td><td>Minus </td><td><code>Arith x Arith</code> </td><td><code>Arith</code> </td><td><code>-</code> </td></tr>
<tr>
<td>136 </td><td>Mod </td><td><code>Arith x Arith</code> </td><td><code>Arith</code> </td><td>Modulo </td></tr>
<tr>
<td>137 </td><td>Neg </td><td><code>Arith</code> </td><td><code>Arith</code> </td><td>Negation </td></tr>
<tr>
<td>138 </td><td>NoOp </td><td><code>(T)+</code> </td><td><code>(T)+</code> </td><td>Returns the input </td></tr>
<tr>
<td>139 </td><td>Not </td><td><code>Boolean</code> </td><td><code>Boolean</code> </td><td>Not </td></tr>
<tr>
<td>140 </td><td>NotEqual </td><td><code>atom x atom</code> </td><td><code>Boolean</code> </td><td><code>!=</code> Also represents exclusive or when used on boolean types </td></tr>
<tr>
<td>141 </td><td>Plus </td><td><code>Algeb x Algeb</code> </td><td><code>Algeb</code> </td><td><code>+</code> when used on <em>arith</em> types, <em>or</em> when used on boolean types </td></tr>
<tr>
<td>142 </td><td>RangeGenerate </td><td><code>Int x Int</code> </td><td><code>Multiple(Int)</code> </td><td><b>Only appears in forall generator</b> <br />
Generates an inclusive sequence between the first and second int. </td></tr>
<tr>
<td>143 </td><td>RBuild </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>144 </td><td>RElements </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>145 </td><td>RReplace </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>146 <br />
147<br />
148<br />
149</td><td>RedLeft<br />
RedRight<br />
RedTree<br />
Reduce </td><td><code>func x T x Mult(T) x [Mult(Bool)]</code> </td><td><code>T</code> </td><td><b>Only used in return subgraph</b> <br />
Works like foldl, the 3rd argument determines if this element is used. <br />
The suffixes determine if the function is left, right, undetermined or pairwise associative. <br />
func is a string literal representing one of the following functions: <br />
 {<em>sum, product,least, greatest, catenate</em>} </td></tr>
<tr>
<td>150 </td><td>RestValues </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>151 </td><td>Single </td><td><code>Double OR Int</code> </td><td><code>Real</code> </td><td>Converts to real, error if it's outside the range of real numbers. </td></tr>
<tr>
<td>152 </td><td>Times </td><td><code>Algeb x Algeb</code> </td><td><code>Algeb</code> </td><td><code>*</code> when used on <em>arith</em> types, <em>and</em> when used on boolean types </td></tr>
<tr>
<td>153 </td><td>Trunc </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>154 </td><td>PrefixSize </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>155 </td><td>Error </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>156 </td><td>ReplaceMulti </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>157 </td><td>Convert </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>158 </td><td>CallForeign </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>159 </td><td>AElementN </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>160 </td><td>AElementP </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>161 </td><td>AElementM </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>170 </td><td>AAddLAT </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>171 </td><td>AAddHAT </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>172 </td><td>ABufPartition </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>173 </td><td>ABuildAT </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>174 </td><td>ABufScatter </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>175 </td><td>ACatenateAT </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>176 </td><td>AElementAT </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>177 </td><td>AExtractAT </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>178 </td><td>AFillAT </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>179 </td><td>AGatherAT </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>180 </td><td>ARemHAT </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>181 </td><td>ARemLAT </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>182 </td><td>AReplaceAT </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>183 </td><td>ArrayToBuf </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>184 </td><td>ASetLAT </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>185 </td><td>DefArrayBuf </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>186 </td><td>DefRecordBuf </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>187 </td><td>FinalValueAT </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>188 </td><td>MemAlloc </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>189 </td><td>BufElements </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>190 </td><td>RBuildAT </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>191 </td><td>RecordToBuf </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>192 </td><td>RElementsAT </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>193 </td><td>ReduceAT </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>19 </td><td>ShiftBuffer </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>195 </td><td>ScatterBufPartitions </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>196 </td><td>RedLeftAT </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>197 </td><td>RedRightAT </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
<tr>
<td>198 </td><td>RedTreeAT </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td><td><b>Unknown</b> </td></tr>
</table>
<h2><a class="anchor" id="Nodes_Comound"></a>
Compound Nodes</h2>
<p>What follows is a table defining the different compound nodes and their labels, an explanation of every compound node follows afterwards.</p>
<table class="doxtable">
<tr>
<th>Label </th><th>Name  </th></tr>
<tr>
<td>0 </td><td>Forall </td></tr>
<tr>
<td>1 </td><td>Select </td></tr>
<tr>
<td>2 </td><td>TagCase </td></tr>
<tr>
<td>3 </td><td>LoopA </td></tr>
<tr>
<td>4 </td><td>LoopB </td></tr>
<tr>
<td>5 </td><td>IfThenElse </td></tr>
<tr>
<td>6 </td><td>Iterate </td></tr>
<tr>
<td>7 </td><td>WhileLoop </td></tr>
<tr>
<td>8 </td><td>RepeatLoop </td></tr>
<tr>
<td>9 </td><td>SeqForall </td></tr>
<tr>
<td>10 </td><td>UReduce </td></tr>
</table>
<h3>Select</h3>
<ul>
<li>Goal: The select node represents a multiway selection. Sisal only supports a 2 way selection, but this compound node could be used to implement different constructs such as a switch too.</li>
<li>Subnodes:<ul>
<li>1 predicate node that returns a number between 0 and n - 1, n being the amount of subnodes.</li>
<li>Every other node is a path that can be followed depending on the result of the predicate.</li>
</ul>
</li>
<li>Association list:<ul>
<li>At least 3 associations (predicate, iftrue and iffalse in case of if)</li>
<li>First element identifies predicate subgraph</li>
<li>Every other element identify the subgraph to use for a given predicate result.</li>
</ul>
</li>
<li>Signature: <code>(value)+ -&gt; (value)+</code></li>
</ul>
<h3>Forall</h3>
<ul>
<li>Goal: Independent execution of multiple instances of an expression</li>
<li>Subnodes:<ul>
<li><b>Generator:</b> Produce values for every instance of the body</li>
<li><b>Body:</b> Expression to be evaluated</li>
<li><b>Results:</b> Gathers the <em>ordered</em> results.</li>
</ul>
</li>
<li>Association list:<ul>
<li>Generator</li>
<li>Body</li>
<li>Returns</li>
</ul>
</li>
<li>Signature: <code>(value)+ -&gt; (value)+</code></li>
</ul>
<h3>LoopA</h3>
<ul>
<li>Goal: Iterative looping construct. Stops when the <em>test</em> subgraph returns false. The test is executed after the body has executed once.</li>
<li>Subnodes:<ul>
<li>Initialization</li>
<li>Test</li>
<li>Body</li>
<li>Returns</li>
</ul>
</li>
<li>Association list:<ul>
<li>Same order as subnodes</li>
</ul>
</li>
<li>Signature: <code>(value)+ -&gt; (value)+</code></li>
</ul>
<h3>LoopB</h3>
<ul>
<li>Goal: Iterative looping construct. Stops when the <em>test</em> subgraph returns false. The test is executed before the body is executed for the first time.</li>
<li>Subnodes:<ul>
<li>Initialization</li>
<li>Test</li>
<li>Body</li>
<li>Returns</li>
</ul>
</li>
<li>Association list:<ul>
<li>Same order as subnodes</li>
</ul>
</li>
<li>Signature: <code>(value)+ -&gt; (value)+</code></li>
</ul>
<h3>TagCase</h3>
<p><b>Unknown</b></p>
<h3>IfThenEl</h3>
<p><b>Unknown</b></p>
<h3>Iterate</h3>
<p><b>Unknown</b></p>
<h3>WhileLoo</h3>
<p><b>Unknown</b></p>
<h3>RepeatLo</h3>
<p><b>Unknown</b></p>
<h3>SeqForal</h3>
<p><b>Unknown</b></p>
<h3>UReduce</h3>
<p><b>Unknown</b> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Sep 30 2014 15:17:24 for Dataflow Software Stack by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
