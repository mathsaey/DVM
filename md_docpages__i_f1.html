<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>DVM: IF1 Quick Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DVM
   </div>
   <div id="projectbrief">DataFlow Virtual Machine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">IF1 Quick Reference </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Concepts">IF1 Concepts</a></li>
<li class="level1"><a href="#Form">IF1 Instructions</a><ul><li class="level2"><a href="#types">Labels and Types</a></li>
</ul>
</li>
<li class="level1"><a href="#Comments">Appendix A: Comments</a><ul><li class="level2"><a href="#Stamps">Stamps</a></li>
<li class="level2"><a href="#Pragmas">Pragmas</a></li>
</ul>
</li>
<li class="level1"><a href="#Literal_def">Appendix B: Literal Definitions</a></li>
</ul>
</div>
<div class="textblock"><p>This page serves as a basic introduction to the IF1 language. The information on this page is based on the paper: <code>IF1 - An Intermediate Form for Applicative Languages. (Stephen Skedzielewski 1985)</code></p>
<p>On this page, we attempt to create a compact IF1 overview that can serve as a full reference to the language while still being complete. If you like to look at an example while browsing this page, check out <a class="el" href="_q_s_i_f1.html">Quicksort in IF1</a>, generated from <a class="el" href="_q_s_sis.html">this sisal code</a>.</p>
<h1><a class="anchor" id="Concepts"></a>
IF1 Concepts</h1>
<p>IF1 represents directed, acyclic graphs, these graphs have a few components.</p>
<ul>
<li>IF1 nodes are operations.<ul>
<li>a node can have an arbitrary amount of in -and outputs.</li>
<li>IF1 defines over 50 nodes, that is, "native" operations.</li>
<li>The in -and output of a node happens through <b>ports</b>, which are numbered indicators of in and output locations</li>
<li>Not every node has a predefined amount of ports.</li>
</ul>
</li>
<li>Edges represent data paths between nodes.<ul>
<li>Edges carry <b>type information</b><ul>
<li>Not mandatory</li>
<li>Can describe user-defined types and built-in types.</li>
</ul>
</li>
<li>A special edge exists to describe literal constants.<ul>
<li>Don't contain a source port</li>
<li>Contain the text of a literal as a string.</li>
</ul>
</li>
</ul>
</li>
<li>Graph boundaries surround groups of nodes and edges.</li>
</ul>
<h1><a class="anchor" id="Form"></a>
IF1 Instructions</h1>
<p>IF1 instructions are delimited by newlines. The first character after a newline determines the type of instruction the line represents, the rest of the line consists of a number of whitespace separated fields, the amount of which depends on that specific instruction. Any extra text listed after the fields is considered to be a comment, so are lines that start with C. For more information about comments, look into <a href="#Comments">appendix A</a>.</p>
<p>The following table lists the different instructions types.</p>
<table class="doxtable">
<tr>
<th>Character </th><th>Represents </th><th>Syntax  </th></tr>
<tr>
<td>T </td><td>type </td><td><code>T label type_code arg_1 arg_2</code> </td></tr>
<tr>
<td>E </td><td>edge </td><td><code>E source_node port destination_node port type</code> </td></tr>
<tr>
<td>L </td><td>literal </td><td><code>L destination_node port type string</code> </td></tr>
<tr>
<td>G </td><td>subgraph of a compound node </td><td><code>G type_reference</code> </td></tr>
<tr>
<td>G </td><td>local function graph </td><td><code>G type_reference "name"</code> </td></tr>
<tr>
<td>X </td><td>global function graph </td><td><code>X type_reference "name"</code> </td></tr>
<tr>
<td>I </td><td>imported function </td><td><code>I type_reference "name"</code> </td></tr>
<tr>
<td>N </td><td>simple node </td><td><code>N label operation</code> </td></tr>
<tr>
<td>{ </td><td>start compound node </td><td><code>{</code> </td></tr>
<tr>
<td>} </td><td>end compound node </td><td>`} label operation association_list_length association_list_element_1 association_list_element_2 ... </td></tr>
</table>
<p>The semantics of these instructions are explained below, explanation about <em>labels</em> and <em>types</em> are presented in the <a href="#types">labels and types</a> section.</p>
<ul>
<li>Simple nodes simply contain a label and an identifier, this identifier represents a native IF1 instruction.</li>
<li>Compound nodes contain subgraphs and represent more complex operations, such as a for loop.</li>
<li>The compound node contains a few subgraphs that represent parts of the compound node, such as the initialization and the condition check, the association list shows which subgraphs represent which action.</li>
<li>Graph boundaries represent a function and simply contain the type (check out the function type) and name of this function.</li>
<li>Graph boundaries have a scope associated with them, anything below the boundary declaration is part of the graph's scope until either a "}, G,X or I" is encountered.</li>
<li>Subgraphs in compound nodes are not required to give a type.</li>
<li>Edges simply contain the input node, and the port on this node, the destination node, and the port on this node that this edge leads to. Furthermore, the edge also contains the type of it's data.</li>
<li>Literals contain their destination, the port on this destination, their type and a string version of their counts. <a href="ref #Literal_def">Appendix B</a> contains an overview of some of the most common literals.</li>
</ul>
<h2><a class="anchor" id="types"></a>
Labels and Types</h2>
<p>IF1 instructions commonly contain a type identifier, the purpose of this section is to explain IF1 type definitions, any defined type is referred to by it's <em>label</em>.</p>
<p>Labels are represented by integers, and are used to identify nodes and types. Nodes and types do not share labels, that is, a node and a type may have the same integer as label without being related in any way. Type labels share a global scope, while Node labels only have to be unique within their enclosing graph. It's also worth noting that a missing or unknown type is referred to by using the label 0.</p>
<p>With that being said, we can look at the type definitions: </p>
<pre class="fragment">T label type_code arg_1 arg_2
</pre><ul>
<li>Label can be used to refer to the type later on.</li>
<li>The type code can be considers to be an argument that indicates what type of type we are dealing with, based on this information, the basic_type is used as another argument to construct the actual type.</li>
<li>The exact use of the other codes depends on the type_code.</li>
</ul>
<p>To clarify this, let's look at a basic sisal types. In this case, the boolean.</p>
<p><code>T 1 1 0 na=Boolean</code></p>
<ul>
<li>T implies that we are declaring a type</li>
<li>1 is the <em>label</em> of the type, it will be used to refer to the type we are constructing from now on.</li>
<li>1 is the <em>type_code</em> of the type. This particular type code tells us that we are dealing with a <em>basic code</em>.</li>
<li>From the information of the type_code, we know that 0 is a basic code, in this case the basic code 0 represents a boolean.</li>
<li>The rest of the line is a comment, it tells us we are dealing with a boolean.</li>
</ul>
<p>What follows is a table of the possible type codes and their meaning.</p>
<table class="doxtable">
<tr>
<th>Code </th><th>Type </th><th>Argument 1 </th><th>Argument 2  </th></tr>
<tr>
<td>0 </td><td>Array </td><td>Base type </td><td><code>none</code> </td></tr>
<tr>
<td>1 </td><td>Basic code </td><td>Basic code </td><td><code>none</code> </td></tr>
<tr>
<td>2 </td><td>Field </td><td>Field type </td><td>Next field </td></tr>
<tr>
<td>3 </td><td>Function </td><td>Argument type </td><td>Result type </td></tr>
<tr>
<td>4 </td><td>Multiple </td><td>Base type </td><td><code>none</code> </td></tr>
<tr>
<td>5 </td><td>Record </td><td>First field </td><td><code>none</code> </td></tr>
<tr>
<td>6 </td><td>Stream </td><td>Base type </td><td><code>none</code> </td></tr>
<tr>
<td>7 </td><td>Tag </td><td>Tag type </td><td>Next tag </td></tr>
<tr>
<td>8 </td><td>Tuple </td><td>Type </td><td>Next in tuple </td></tr>
<tr>
<td>9 </td><td>Union </td><td>First Tag </td><td><code>none</code> </td></tr>
</table>
<p>In the following section, the different types are described.</p>
<h4>Basic types</h4>
<p>As the example in the parent section indicates, basic types simply indicate a standard type, the argument is simply a code that tells us which type we are dealing with. A table with the basic types and their code can be found below.</p>
<table class="doxtable">
<tr>
<th>Code </th><th>Type  </th></tr>
<tr>
<td>0 </td><td>Boolean </td></tr>
<tr>
<td>1 </td><td>Character </td></tr>
<tr>
<td>2 </td><td>Double </td></tr>
<tr>
<td>3 </td><td>Integer </td></tr>
<tr>
<td>4 </td><td>Null </td></tr>
<tr>
<td>5 </td><td>Real </td></tr>
<tr>
<td>6 </td><td>WildBasic* </td></tr>
</table>
<p>`* This type does not appear in the official reference, but is generated by sisalc 14.1.</p>
<h4>Array and Streams</h4>
<p>Arrays and streams simply point to the <em>label</em> of the type they contain.</p>
<h4>Records and fields, unions and tags. And tuples.</h4>
<p>A record can be seen as a pointer to a field. It simply contains it's label, the type_code that indicates it's a record and the <em>label</em> of it's first field.</p>
<p>A field contains it's label, it's type_code, the <em>label</em> of the type it contains, and the <em>label</em> of the next field. The last field contains 0 as the <em>label</em> that points to the next field.</p>
<p>Unions and tags work in the same way, the only difference is that unions can be seen as a pointer to a tag. A tag points to the next tag like a field points to the next field.</p>
<p>Tuples follow the same contain your own type, point to the next one convention, but don't require an initial pointer.</p>
<h4>Functions</h4>
<p>A function type simple contains "pointers" to 2 tuples, the first tuple represents the arguments this function accepts while the second tuple represents the result it returns.</p>
<p>In terms of higher level languages, the function type simple declares the function's signature, without the name.</p>
<h1><a class="anchor" id="Comments"></a>
Appendix A: Comments</h1>
<p>2 main types of comments exist in IF1, stamps and pragmas, stamps are comments that occupy an entire line that starts with <code>C$</code>, pragmas are comments that are added after the fields of a line.</p>
<h2><a class="anchor" id="Stamps"></a>
Stamps</h2>
<p>Stamps are used to mark some processing that has been done to a file, a few stamp type exists. A stamp line has the following syntax: <code>C$ stamp_type info</code>. The following table provides an overview of the different stamp types.</p>
<table class="doxtable">
<tr>
<th>Character </th><th>Meaning  </th></tr>
<tr>
<td>A </td><td>Array update analysis </td></tr>
<tr>
<td>C </td><td>Structure checker </td></tr>
<tr>
<td>D </td><td>Order nodes using data dependencies </td></tr>
<tr>
<td>E </td><td>Common subexpression information </td></tr>
<tr>
<td>F </td><td>Frontend </td></tr>
<tr>
<td>L </td><td>Loop invariant removal </td></tr>
<tr>
<td>O </td><td>Add offsets for use by the interpreter </td></tr>
<tr>
<td>P </td><td>Partitioning analysis </td></tr>
<tr>
<td>S </td><td>Stream analysis </td></tr>
<tr>
<td>V </td><td>Vector analysis </td></tr>
</table>
<h2><a class="anchor" id="Pragmas"></a>
Pragmas</h2>
<p>Pragmas are used to add additional information to an instruction. Currently, 2 types of pragmas exist, pragmas that are generated by the compiler, and pragmas that are added after analyzing. Multiple pragmas can be added after a single instruction. Pragmas are terminated by a whitespace character.</p>
<p>Pragmas have the following syntax: <code>%&lt;id&gt;=&lt;anything&gt;,&lt;otheranything&gt; %&lt;otherid&gt;=&lt;anything&gt;</code></p>
<p>The following table provides an overview of the meaning of different pragmas. The type column indicates the type of pragma; C indicates a compiler-generated pragma, while A indicates a pragma generated by analyzing.</p>
<table class="doxtable">
<tr>
<th>Character </th><th>Type </th><th>Meaning  </th></tr>
<tr>
<td>bd </td><td>C </td><td>bounds </td></tr>
<tr>
<td>na </td><td>C </td><td>name </td></tr>
<tr>
<td>sl </td><td>C </td><td>source line </td></tr>
<tr>
<td>op </td><td>C </td><td>op number with line of source </td></tr>
<tr>
<td>ar </td><td>A </td><td>size of activation record needed </td></tr>
<tr>
<td>lz </td><td>A </td><td>edge carries a value that must be demanded </td></tr>
<tr>
<td>mk </td><td>A </td><td>mark this edge by reference (mk=r) or by value (mk=v) </td></tr>
<tr>
<td>of </td><td>A </td><td>offset in activation record </td></tr>
<tr>
<td>st </td><td>A </td><td>style of memory allocation (st=p for pointer, st=c for contiguous) </td></tr>
<tr>
<td>xy </td><td>A </td><td>position for node in graphic output </td></tr>
</table>
<h1><a class="anchor" id="Literal_def"></a>
Appendix B: Literal Definitions</h1>
<table class="doxtable">
<tr>
<th>Type </th><th>String  </th></tr>
<tr>
<td>Function names </td><td>"someName" </td></tr>
<tr>
<td>Boolean values </td><td>"T" or "F" </td></tr>
<tr>
<td>Integer values </td><td>"03349" </td></tr>
<tr>
<td>Characters </td><td>"'\n'" or "'x'" </td></tr>
<tr>
<td>Null value </td><td>nil </td></tr>
<tr>
<td>Single-precision floating point value </td><td>"3.503" or "5e3" or ".503" </td></tr>
<tr>
<td>Double-precision floating point value </td><td>"6.626198d-34" ".056D24" </td></tr>
</table>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 30 2013 01:34:11 for DVM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
