<!-- Written by Mathijs Saey at the VUB, all rights reserved -->

[TOC]

# Introduction {#Introduction}

This is the main documentation of DVM, the Dataflow Virtual Machine, created by Mathijs Saey for his thesis at the VUB.

These pages serve a number of purposes:
* [Provide a basic overview about DVM.](#About)
* [Provide a high-level overview of the code base.](#Structure)
* [Collect the documentation about the DVM code base](files.html)
* [Collect all the necessary information to get DVM up and running](#Start)
* [Collect references and examples that can come in handy while working on DVM.](pages.html)

It should be noted that the version string next to the project name in the header of any page of this documentation corresponds to a commit hash. This hash can be used to find the exact codebase that was used to generate the docs.

Finally, the main repository of this project can be found [on github](https://github.com/mathsaey/DVM).

# About DVM {#About}

The goal of DVM is to create a highly parallel virtual machine. This machine will use the [dataflow architecturee](http://en.wikipedia.org/wiki/Dataflow_architecture) to achieve a high amount of parallelism.

## Dataflow {#Dataflow}
<img style="float: right" src="simpleStatic.png"/>

In short, the general idea behind [dataflow](http://en.wikipedia.org/wiki/Dataflow_architecture) is that an instruction in the program is executed once it's inputs are ready. This property allows us to exploit the implicit parallelism of programs. A dataflow program can be represented as a graph, in such a graph, nodes represent operations while edges represent data dependencies between these operations.

A visual representation of such a dataflow graph can be seen right of this section. This graph was generated from the following Sisal code.

~~~
function main(a, b, c, d : integer returns integer)
	let 
		ab := a + b;
		cd := c + d
	in 
		ab + cd 
	end let
end function
~~~

As we can see, this program simply takes 4 inputs, and adds all of these together. The generated dataflow graph shows us that both of the additions could be carried out in parallel.

Concretely, DVM utilizes a tagged-token dataflow architecture to execute such a dataflow program. In such an architecture, each token (i.e. a piece of data traveling through the program) contains a *tag* which contains the destination of this token, and a datum, which stores the actual data that is transported. Various elements of the DVM execution pipeline handle such a token, which leads to the production of new tokens. This pipeline system is represented in the image below.

![DVM execution pipeline](pipeline.png)

## Sisal and IF1 {#IF1}

[Sisal](http://en.wikipedia.org/wiki/SISAL) is a language designed to be a high level variant for languages such as PASCAL that can work on multicore machines. During the first compilation phase sisalc (the sisal compiler) compiles Sisal to IF1, an intermediate language, which represents the sisal source code as a dataflow graph. 

DVM is focused on the execution of a dataflow program, and not on the language or compiler design. For this reason, we decided to use IF1 as the primary input language of DVM. Using DVM in combination with [sisalc](http://sourceforge.net/projects/sisal/) offers us a high-level language for writing dataflow programs, along with a compiler that removes the complexity of the language for us.

More information about IF1 along with some sisal and IF1 code samples can be found in the [IF1 overview](md_doc__i_f1.html). 

## In General {#General}

To recap, DVM is a virtual machine that attempts to achieve high levels of parallelism. In order to do this, DVM utilizes a tagged-token dataflow architecture. DVM uses IF1 as an input language, as generated by sisalc, the Sisal compiler. 

# Getting started {#Start}

Running DVM is quite trivial at the moment. All you need is a working [python](http://www.python.org/) interpreter. Man pages for DVM and DISc can be found in the [resources folder of the repository](https://github.com/mathsaey/DVM/tree/master/res).

You need to install [sisalc](http://sourceforge.net/projects/sisal/), the sisal C compiler if you want to produce your own IF1 files from sisal source code.

The sites of all these tools and the used versions can be found below:

Tool     | Version | Website
---------|---------|--------
`sisalc` | 14.1.0  | http://sourceforge.net/projects/sisal/
`python` | 2.7.6   | http://www.python.org/

# Overall Structure {#Structure}

DVM is split up into 2 components:

* DVM, the actual execution engine. Which accepts [DIS](md_doc__d_i_s.html) as input.
* DISc, A DIS Compiler built on IGR. This is based on 3 foundations:
	* IGR, the Intermediate Graph Representation, a flexible, graph-based representation that is the foundation of our compiler.
	* An easily extensible set of front-ends that parse a source language and turn it into IGR.
	* An extensible set of back-ends that apply a few transformations to IGR, before mapping it to DIS.
