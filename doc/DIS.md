<!-- Written by Mathijs Saey at the VUB, all rights reserved -->

# General {#General}

[TOC]

This page defines the standard of DIS, the DVM Instruction Set. DIS is the only input accept by DVM, and can be generated by an external tool. As the name might say, DIS simply contains the instruction set that DVM uses to execute programs. Simply said, DIS is a string representation of the DVM instruction memory.

## The Instruction Memory. {#Memory}

Seeing that DIS is a string version of the instruction memory, it might be handy to know what the instruction memory looks like. 

The DVM instruction memory is divided into **chunks**, each of these chunks contains instructions that have certain properties. At the time of writing, the instruction memory contains 2 chunks, instructions that need to be matched by the context matcher and instructions that don't need to be matched.

The instructions that don't need to be matched are located in chunk 0, while those that need to be matched are located in chunk 1.

# DIS file layout {#Layout}

A DIS file contains 3 types of statements:
	* Chunck declarations
	* Instruction definitionss
	* Links between instructions.

Besides these, DIS can contain comment lines. A comment line is a line that starts with `$`. Furthermore, anything noted after a statement is also silently ignored. This means that this data can be effectively considered as a comment. For convenience, it is still recommend to put a `$` in front of any intended comment.

The following sections detail the exact nature of the other statements.

## Chunks {#Chunks}

Like the instruction memory, a DIS file is divided in chunks. A chunk simply contains all the instructions present in this chunk, separated by newlines.

A new chunk is started with the following statement:

    CHUNCK <idx>

Where chunk is a keyword while idx is the index of the chunk. A chunk ends when a new chunk begins or when the file ends. It is not possible to nest chunks.

## Links {#Links}

A link allows us to define from-to relationships between instructions. A link is added in the following way:

    LINK <from> <to>

Where LINK is a keyword while from is the address (chunk, instruction, port) of the port on the source node while to is the address of the port on the to node.

A port address is represented with the following syntax:

    [<chunk> <instruction> <port>]


Thus a link from port 0 of instruction 3 in chunk 0 to port 0 of instruction 1 in chunk 1 would look like this:

    LINK [0 3 0] [0 1 0]

Links can occur anywhere in the file, and transcend chunk boundaries. 

## Instructions {#Instructions}

An instruction in DIS looks like this:

    INST <idx> <type> <args>

Where idx is the index of the instruction in the chunk of memory, while type is the type of instruction we are creating. Args represents the arguments. These depend on the type of instruction.


### Instructions Types

The following table defines the possible instruction types, their type code and the argument string they accept. Additional explanation on each of these types can be found below.

Type | Code | Args 
-----| -----|------
[Sink](\ref core::instruction::Sink) | 0 | `None`
[ContextChange](\ref core::instruction::ContextChange) | 1 | `<to> <return sink>`
[ContextRestore](\ref core::instruction::ContextRestore) | 2 | `None`
[OperationInstruction](\ref core::instruction::OperationInstruction) | 3 | `<opCode> <inputs>`

#### Sinks

Sinks are the the simplest instruction that is available. A sink is a simple link between a from and to. It will send whatever input it receives on a port to the destination for that port.

Sinks are mainly used to have a static point in the program that can catch input (such as the start of a function). A sink takes no arguments, since it's behavior is defined by it's destinations, which are added through links. There is one exception to this rule, which can be found in the [constraints](#Constraints) section.

#### ContextChange

A Context change instruction changes the context of a token. Look into the [documentation](\ref core::instruction::ContextChange) for further information.

A context change instruction takes to arguments, the address to a sink, which will be the destination of any token that enters the instruction. And the address of a return sink, which will catch anything that is returned when the context is restored.

Such an address is similar to a link address:

    [<chunk> <instruction>]

Thus a context change instruction is added in the following manner:

    INST 2 1 [0 4] [0 3]


#### Context Restore

A context Restore finds the return instruction of a token based on it's context and sends it to that location. It can be compared to a return from a call. Once again, we refer to the [documentation](\ref core::instruction::ContextRestore) for additional information.

A context restore takes no arguments.

#### Operation Instruction

An operation instruction represents an operation on the data of a set of tokens. It takes an opcode, which represents the operation it performs, a number detailing the amount of inputs it should receive.

# Additional constraints {#Constraints}

In order to communicate with the outside world, the DVM needs to have a predefined entry and exit point to the program. These are achieved by using a special instruction that can only be used for this purpose. These special instructions have to be placed at predefined locations.

The entry point of the program should be located in chunk 0 at address 0, while the exit point should be located at chunk 0 at address 0. Both of these points should be sink instructions, which **take one additional argument*, namely the amount of inputs/outputs the accept/return. These are used by the runtime to determine if the program requires additional input and if it has stopped. We declare these instructions in the following way:

entry point: 

    INST 0 0 <inputs>

exit point:

    INST 1 0 <outputs>
    

# An example

The example below presents the DIS code for a program that simply calls a function which adds both of it's inputs. It is roughly equivalent to the following pseudo code.

~~~~
function add(x, y):
	return x + y
end function

function Main(x, y):
	return add(x,y)
end function
~~~~

\include simple.dis
