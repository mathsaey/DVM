<!-- Written by Mathijs Saey at the VUB, all rights reserved -->

# General

This page defines the standard of DIS, the DVM Instruction Set. DIS is the only input accept by DVM, and can be generated by an external tool. As the name might say, DIS simply contains the instruction set that DVM uses to execute programs. Simply said, DIS is a string representation of the DVM instruction memory.

## The Instruction Memory.

Seeing that DIS is a string version of the instruction memory, it might be handy to know what the instruction memory looks like. 

The DVM instruction memory is divided into **chunks**, each of these chunks contains instructions that have certain properties. At the time of writing, the instruction memory contains 2 chunks, instructions that need to be matched by the context matcher and instructions that don't need to be matched.

The instructions that don't need to be matched are located in chunk 0, while those that need to be matched are located in chunk 1.

# DIS file layout

A DIS file contains 3 types of statements:
	* Chunck declarations
	* Instruction definitionss
	* Links between instructions.

Besides these, DIS can contain comment lines. A comment line is a line that starts with `$`. Furthermore, anything noted after a statement is also silently ignored. This means that this data can be effectively considered as a comment. For convenience, it is still recommend to put a `$` in front of any intended comment.

Like the instruction memory, a DIS file is divided in chunks. A chunk simply contains all the instructions present in this chunk, separated by newlines.

A new chunk is started with the following statement:

    CHUNCK <idx>

Where chunk is a keyword while idx is the index of the chunk. A chunk ends when a new chunk begins or when the file ends. It is not possible to nest chunks.

Besides chunks, DIS only contains instructions, destinations and comments. A comment is started with the `$` sign. The $ sign should be located at the start of the line. Empty lines are ignored. Anything after the needed length of a line is ignored. So if you write CHUNCK 1 foobar, foobar will not be parsed. For convenience, it is still recommend to put a $ in front of the ignored part of a line.

# Destination representation

A destination links 2 instructions together. Destinations cross chunk bound


# Instruction representation

An instruction in DIS looks like this:

    INST <idx> <type> <args>

Where idx is the index of the instruction in the chunk of memory, while type is the type of instruction we are creating. Args represents the arguments. These depend on the type of instruction.


## Instruction Types

The following table defines the possible instruction types, their type code and the argument string they accept. Additional explanation on each of these types can be found below.

Type | Code | Args 
-----| -----|------
[Sink](\ref core::instruction::Sink) | 0 | `None`
[ContextChange](\ref core::instruction::ContextChange) | 1 | `<to> <return sink>`
[ContextRestore](\ref core::instruction::ContextRestore) | 2 | `None`
[OperationInstruction](\ref core::instruction::OperationInstruction) | 3 | `<opCode> <inputList>`

# Entry and Exit Point

In order to communicate with the outside world, the DVM needs to have a predefined entry and exit point to the program. These are achieved by using a special instruction that can only be used for this purpose. These special instructions have to be placed at predefined locations.

The entry point of the program should be located in chunk 0 at address 0, while the exit point should be located at chunk 0 at address 0. Both of these points should be sink instructions, which **take one additional argument*, namely the amount of inputs/outputs the accept/return. These are used by the runtime to determine if the program requires additional input and if it has stopped. We declare these instructions in the following way:

entry point: 

    INST 0 0 <inputs>

exit point:

    INST 1 0 <outputs>
    

# An example

\include simple.dis
