<?xml version="1.0" encoding="UTF-8"?>
<Tokens version="1.0">
  <Token>
    <TokenIdentifier>
      <Name>addOperationInstruction</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm</Scope>
    </TokenIdentifier>
    <Path>namespacedvm.html</Path>
    <Anchor>aab958de8f0a34977369e337af856cc0c</Anchor>
    <Abstract>Add an operation instruction. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addSink</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm</Scope>
    </TokenIdentifier>
    <Path>namespacedvm.html</Path>
    <Anchor>ae79b89566a5fa959017e1c4f4e2194e8</Anchor>
    <Abstract>Add a sink instruction. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addContextChange</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm</Scope>
    </TokenIdentifier>
    <Path>namespacedvm.html</Path>
    <Anchor>a82f3c258dc8312f18ca461a74247b584</Anchor>
    <Abstract>Add a context change instruction. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addContextRestore</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm</Scope>
    </TokenIdentifier>
    <Path>namespacedvm.html</Path>
    <Anchor>acd810468527bd761f08c4701a07d2bb7</Anchor>
    <Abstract>Add a context restore instruction. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addStopInstruction</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm</Scope>
    </TokenIdentifier>
    <Path>namespacedvm.html</Path>
    <Anchor>abe4bfce9e8136880a7dc8fcc58835bc7</Anchor>
    <Abstract>Add a stop instruction. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addDestination</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm</Scope>
    </TokenIdentifier>
    <Path>namespacedvm.html</Path>
    <Anchor>aec3ef29b6ff8be5daecd17e314959628</Anchor>
    <Abstract>Add a destination to a given instruction. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>start</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm</Scope>
    </TokenIdentifier>
    <Path>namespacedvm.html</Path>
    <Anchor>a98adedcf92f4a2d4c6e0a81d3e5e55ce</Anchor>
    <Abstract>Start program execution. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>parseFile</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser.html</Path>
    <Anchor>a0dd29707e7f3446442354f71fd89ea03</Anchor>
    <Abstract>Parses an IF1 file. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getSubGraphs</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr</Scope>
    </TokenIdentifier>
    <Path>namespaceigr.html</Path>
    <Anchor>a5f6af71dfd54044f478676514a3601aa</Anchor>
    <Abstract>Get a list of all the non-compound subgraphs in the program. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getSubGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr</Scope>
    </TokenIdentifier>
    <Path>namespaceigr.html</Path>
    <Anchor>a7179cb2c7d63947e8b423900b5dae82c</Anchor>
    <Abstract>Get a subgraph by name. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>createGeneralSubGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr</Scope>
    </TokenIdentifier>
    <Path>namespaceigr.html</Path>
    <Anchor>afbec9b955b6149a93149906f49cd2799</Anchor>
    <Abstract>Create a new subgraph. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>createSubGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr</Scope>
    </TokenIdentifier>
    <Path>namespaceigr.html</Path>
    <Anchor>a9b6d2c8d74c030f5afbad3c4ab866bce</Anchor>
    <Abstract>Create a subgraph and add it to the program graph. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>createCompoundSubGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr</Scope>
    </TokenIdentifier>
    <Path>namespaceigr.html</Path>
    <Anchor>aa6fd9ac3ba0d7cb2dfa515877dbf31e6</Anchor>
    <Abstract>Create a subgraph for a compound node. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>createNode</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr</Scope>
    </TokenIdentifier>
    <Path>namespaceigr.html</Path>
    <Anchor>a4c219a3f0d67516d3d7ecf9fbf1a3f1c</Anchor>
    <Abstract>Create a node, add it to it&amp;#39;s subgraph and return it. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>createOperationNode</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr</Scope>
    </TokenIdentifier>
    <Path>namespaceigr.html</Path>
    <Anchor>a9bf009f469c784d09bcf69d92fd08c57</Anchor>
    <Abstract>Create an operation node. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>createCompoundNode</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr</Scope>
    </TokenIdentifier>
    <Path>namespaceigr.html</Path>
    <Anchor>af62b226668dfc5dda0c584678f0fde90</Anchor>
    <Abstract>Create a Compound node. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>createCallNode</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr</Scope>
    </TokenIdentifier>
    <Path>namespaceigr.html</Path>
    <Anchor>a78ca4c3daf66bbf0171ae173dcd65bea</Anchor>
    <Abstract>Create a call node. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addLiteral</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr</Scope>
    </TokenIdentifier>
    <Path>namespaceigr.html</Path>
    <Anchor>a725e68f9b33824563a9f1ab374bf05c4</Anchor>
    <Abstract>Add a literal to a port. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>connect</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr</Scope>
    </TokenIdentifier>
    <Path>namespaceigr.html</Path>
    <Anchor>a74d7dd97190a3e48b8109e86786bf283</Anchor>
    <Abstract>Connect 2 ports with an implicit edge. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>subGraphHeader</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>aea31a1aceed8455ba7179e254a677d6c</Anchor>
    <Abstract>Add the attributes of the subgraph. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>subGraphFooter</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>a1f5178873440863fffb6ae47c7202667</Anchor>
    <Abstract>&amp;quot;close&amp;quot; the subgraph. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>portString</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>a2b165c8b0265f5f5d824b0bfc595588a</Anchor>
    <Abstract>Get a representation for a port. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ports</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>acaa819ccaaa232d873ce172287bd857a</Anchor>
    <Abstract>String representation of a port list. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inputList</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>a6df36fb8b1f135d7e646440e6adf39d1</Anchor>
    <Abstract>Get the portlist for the inputs of a node. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>outputList</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>a6a1175fd47928bf210540e06854f884d</Anchor>
    <Abstract>Get the portlist for the outputs of a node. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>nodeIdentifier</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>a7e29902b97989ad0da9f3d3c4055a0c4</Anchor>
    <Abstract>Identifier of the node. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>edgeStr</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>a22d69d4cfb87904a0baa28982d59e7aa</Anchor>
    <Abstract>Convert a connection to a string. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>nodeLabel</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>ae92a24a3e20437518443308493826e39</Anchor>
    <Abstract>Add the label of the node to the buffer. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>nodeLinks</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>aecd94322f518eca095440e929ff869f0</Anchor>
    <Abstract>Add all the outgoing edges of a node to the buffer. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>node</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>ad156d481575b1064cfe3673afb0760c0</Anchor>
    <Abstract>Write the information of a node to the buffer. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dotHeader</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>aa4eab18b90e883fddbf2b7367f654d7b</Anchor>
    <Abstract>Write general dot information. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dotFooter</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>a64ecb170a7342bba287d37909b9d47b2</Anchor>
    <Abstract>Close the dot graph. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getDot</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>aa1c58f873cee40263ac5a2c07fb617b5</Anchor>
    <Abstract>Create the dot string. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dotToFile</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>ab9fb1f388749ced3ba64ee867fae0920</Anchor>
    <Abstract>Get the dot representation and write it to a file. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>runDot</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>ab8d86a047857d932d4a46bced06e74ba</Anchor>
    <Abstract>Convert the IGR graph to dot, save it, and run dot on this file. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>traverseAll</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::traverse</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1traverse.html</Path>
    <Anchor>a8e26de5b58a3972dc0f7a780f64889d4</Anchor>
    <Abstract>Traverse all the nodes in the program. </Abstract>
    <DeclaredIn>traverse.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>memory</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm::memory</Scope>
    </TokenIdentifier>
    <Path>namespacedvm_1_1memory.html</Path>
    <Anchor>a4f967c1cc9fba0a6944d5ad3acfdf23b</Anchor>
    <Abstract>Get a reference to the instruction memory. </Abstract>
    <DeclaredIn>memory.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>reset</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm::memory</Scope>
    </TokenIdentifier>
    <Path>namespacedvm_1_1memory.html</Path>
    <Anchor>a8185b97612cbd51ad34a78aa82293978</Anchor>
    <Abstract>Delete all the contents of the instruction memory. </Abstract>
    <DeclaredIn>memory.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>get</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm::memory</Scope>
    </TokenIdentifier>
    <Path>namespacedvm_1_1memory.html</Path>
    <Anchor>aaa309903cc32fe7a8a4ab0a2a370856b</Anchor>
    <Abstract>Get an instruction from the main memory. </Abstract>
    <DeclaredIn>memory.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>add</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm::memory</Scope>
    </TokenIdentifier>
    <Path>namespacedvm_1_1memory.html</Path>
    <Anchor>a77c9b4a570656fe7004e398d4cfa36aa</Anchor>
    <Abstract>Add an instruction to the main memory. </Abstract>
    <DeclaredIn>memory.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>needsMatcher</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm::memory</Scope>
    </TokenIdentifier>
    <Path>namespacedvm_1_1memory.html</Path>
    <Anchor>aae240e1a45decaa89947497faf0175da</Anchor>
    <Abstract>See if an instruction needs to pass the matcher Instructions that require a context manager are store...</Abstract>
    <DeclaredIn>memory.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__MEMORY__</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>dvm::memory</Scope>
    </TokenIdentifier>
    <Path>namespacedvm_1_1memory.html</Path>
    <Anchor>a2b1f2d9a35d3c9b79a0df2e172fe0410</Anchor>
    <Abstract>Main instance of the instruction memory. </Abstract>
    <DeclaredIn>memory.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__COMPOUNDS__</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>if1parser::compound</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1compound.html</Path>
    <Anchor>a797383d1cc69393e996bfa86123543dd</Anchor>
    <Abstract>Various IGR compound nodes. </Abstract>
    <DeclaredIn>compound.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>parseEdge</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::edge</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1edge.html</Path>
    <Anchor>a9559e91a84e4c6938465015a28a21088</Anchor>
    <Abstract>Parse an IF1 edge. </Abstract>
    <DeclaredIn>edge.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>parseLiteral</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::edge</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1edge.html</Path>
    <Anchor>a92dd2e5c05f3f871cac4da1b86c65cb6</Anchor>
    <Abstract>Parse an IF1 literal. </Abstract>
    <DeclaredIn>edge.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>scope</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>ac3d3b545f999512679672bf888eba1b0</Anchor>
    <Abstract>Create a new scope and push it on top of the stack. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>scopeCompound</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>a9c6dbe85da553aec7e1c56c5e8541dd3</Anchor>
    <Abstract>Create a new compound scope and push it on top of the stack. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>popScope</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>a55892a8042f043de0dc88bfc69c32043</Anchor>
    <Abstract>Remove the current scope. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getNode</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>a96c29b707f105852877f2f57124309d1</Anchor>
    <Abstract>Get the node with label in the current scope. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addNode</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>a85356c8a9cdc471a3629c9ef96a30f15</Anchor>
    <Abstract>Add node with label to the current scope. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getSubGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>a14455ac1a0ea0244fba8ab51ca665784</Anchor>
    <Abstract>Get the subgraph of the current scope. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addSubGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>a73edb1959ff472959bc7c95925c0f2f8</Anchor>
    <Abstract>Add a subgraph to the compound scope. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getSubGraphs</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>a265a80560eda3b9fca53f37793882e6e</Anchor>
    <Abstract>Get the subgraphs. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isCompound</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>a0c850780cfb126dd8744cedbe3bf876d</Anchor>
    <Abstract>Are we currently in a compound node? </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>enterComp</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>aff6442e36aba86f0088dc3161abe3719</Anchor>
    <Abstract>Enter a compound node. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>exitComp</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>ae609458a57295c6f7730d4dc0f590b77</Anchor>
    <Abstract>Exit a compound node. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__STACK__</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>a1a50b4e04442e44e141d765e027c574f</Anchor>
    <Abstract>A stack with the global scope at the bottom, and the current scope at the top. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__COMP_LEVEL__</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>a15eaacefeb3026ee420764029bb3c20a</Anchor>
    <Abstract>Keeps track of the level of depth w.r.t. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>parseSubGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::graph</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1graph.html</Path>
    <Anchor>a89697113e8095d64609a253f171b2851</Anchor>
    <Abstract>Parse a standard subgraph. </Abstract>
    <DeclaredIn>graph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>parseCompoundSubGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::graph</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1graph.html</Path>
    <Anchor>a2bee103d1fa968453a1d358d694b77e0</Anchor>
    <Abstract>Parse a subgraph of a compound node. </Abstract>
    <DeclaredIn>graph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>parseGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::graph</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1graph.html</Path>
    <Anchor>ad0dd06cbdd5630636069753749ed2e60</Anchor>
    <Abstract>Determine which kind of subgraph we are dealing with. </Abstract>
    <DeclaredIn>graph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>parseCompoundStart</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::graph</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1graph.html</Path>
    <Anchor>a3f57a04f39830c78e2e9665f522331eb</Anchor>
    <Abstract>Parse the start of a compound node. </Abstract>
    <DeclaredIn>graph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addSubGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr::graph</Scope>
    </TokenIdentifier>
    <Path>namespaceigr_1_1graph.html</Path>
    <Anchor>af34fc9690d77ea1afbb8ec9461c20d82</Anchor>
    <Abstract>Add a subgraph to the program. </Abstract>
    <DeclaredIn>graph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>bindName</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr::graph</Scope>
    </TokenIdentifier>
    <Path>namespaceigr_1_1graph.html</Path>
    <Anchor>a806e534c157fd842185841c1c9850473</Anchor>
    <Abstract>Add a subgraph to a given name. </Abstract>
    <DeclaredIn>graph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getSubGraphs</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr::graph</Scope>
    </TokenIdentifier>
    <Path>namespaceigr_1_1graph.html</Path>
    <Anchor>a88c9b06d2921992d38875658249813bc</Anchor>
    <Abstract>Get a list of all the non-compound subgraphs in the program. </Abstract>
    <DeclaredIn>graph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getSubGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr::graph</Scope>
    </TokenIdentifier>
    <Path>namespaceigr_1_1graph.html</Path>
    <Anchor>a9be3a51d4d501a7f52b1747d2ae46b03</Anchor>
    <Abstract>Get a subgraph by name. </Abstract>
    <DeclaredIn>graph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__SUBGRAPHS__</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>igr::graph</Scope>
    </TokenIdentifier>
    <Path>namespaceigr_1_1graph.html</Path>
    <Anchor>afdb8217d8e81b26a0c24ed2d8025d3d5</Anchor>
    <Abstract>All of the functions in the program. </Abstract>
    <DeclaredIn>graph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__FUNCTION_NAMES__</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>igr::graph</Scope>
    </TokenIdentifier>
    <Path>namespaceigr_1_1graph.html</Path>
    <Anchor>a9b1232f8e4181818a8d8a2add2ae9639</Anchor>
    <Abstract>The function names, combined with the subgraph they map to. </Abstract>
    <DeclaredIn>graph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>skipLine</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::parser</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1parser.html</Path>
    <Anchor>a2d4a84452234eb18b18bf7734f82310d</Anchor>
    <Abstract>Skip a line #. </Abstract>
    <DeclaredIn>parser.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>parseLine</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::parser</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1parser.html</Path>
    <Anchor>abc99e0a3cd70f9aac6ea3878e52bdfde</Anchor>
    <Abstract>Parse a single if1 line. </Abstract>
    <DeclaredIn>parser.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>parseString</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::parser</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1parser.html</Path>
    <Anchor>aeccd6ca9f1a71f3d78943ecbba250907</Anchor>
    <Abstract>Parse a complete IF1 string. </Abstract>
    <DeclaredIn>parser.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>parseFile</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::parser</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1parser.html</Path>
    <Anchor>ae59b6559232a12495c5a8fc0f9c317cb</Anchor>
    <Abstract>Parses an IF1 file. </Abstract>
    <DeclaredIn>parser.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__FUNCTIONS__</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>if1parser::parser</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1parser.html</Path>
    <Anchor>acee573307f5a5a1c1257f0d46cdce19f</Anchor>
    <Abstract>Parser values and the function to call when they are encountered. </Abstract>
    <DeclaredIn>parser.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>warning</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::tools</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1tools.html</Path>
    <Anchor>afbb6fe73c05c31cda4a0912d0029f382</Anchor>
    <Abstract>Print a warning to stdout. </Abstract>
    <DeclaredIn>tools.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>error</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::tools</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1tools.html</Path>
    <Anchor>a1fb18a2807bc9956f256b59f78d87fbb</Anchor>
    <Abstract>Print an error to stdout. </Abstract>
    <DeclaredIn>tools.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getType</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::type</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1type.html</Path>
    <Anchor>a51af0e361088d1735780e23103356f0e</Anchor>
    <Abstract>Get a type from the pool. </Abstract>
    <DeclaredIn>type.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>_type_codes</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>if1parser::type</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1type.html</Path>
    <Anchor>a9f51012fcb99a6061d1d3c80d6132bdd</Anchor>
    <Abstract>The function that is needed to parse a given idx. </Abstract>
    <DeclaredIn>type.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>_basic_types</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>if1parser::type</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1type.html</Path>
    <Anchor>ad14723757fb16b37b92cc78718733c46</Anchor>
    <Abstract>Basic type codes and the python types to match them. </Abstract>
    <DeclaredIn>type.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getKey</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr::node</Scope>
    </TokenIdentifier>
    <Path>namespaceigr_1_1node.html</Path>
    <Anchor>af484daef5e53d09cd12bff5103857432</Anchor>
    <Abstract>Generate unique id. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>setLock</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>log</Scope>
    </TokenIdentifier>
    <Path>namespacelog.html</Path>
    <Anchor>a19a02b14ef0cf914f9b37cc089b271d4</Anchor>
    <Abstract>Update the lock, this should happen after creating a new process. </Abstract>
    <DeclaredIn>log.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getLock</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>log</Scope>
    </TokenIdentifier>
    <Path>namespacelog.html</Path>
    <Anchor>ab52504cbf016790e76a6c55efd0a0d33</Anchor>
    <Abstract>Get a reference to the loglock. </Abstract>
    <DeclaredIn>log.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>debg</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>log</Scope>
    </TokenIdentifier>
    <Path>namespacelog.html</Path>
    <Anchor>a3437ac04c1bfc9282d9f34d0c3f51594</Anchor>
    <Abstract>Log a debug severity message. </Abstract>
    <DeclaredIn>log.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>info</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>log</Scope>
    </TokenIdentifier>
    <Path>namespacelog.html</Path>
    <Anchor>a8e3ea60d7c7d7695350241b29425b4f9</Anchor>
    <Abstract>Log an information message. </Abstract>
    <DeclaredIn>log.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>warn</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>log</Scope>
    </TokenIdentifier>
    <Path>namespacelog.html</Path>
    <Anchor>a3447b086820a8dcc437791113d4d2402</Anchor>
    <Abstract>Log a warning message. </Abstract>
    <DeclaredIn>log.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>err</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>log</Scope>
    </TokenIdentifier>
    <Path>namespacelog.html</Path>
    <Anchor>acecba27de46867486220dade7ba9e4a2</Anchor>
    <Abstract>Log an error message. </Abstract>
    <DeclaredIn>log.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__severities__</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>log</Scope>
    </TokenIdentifier>
    <Path>namespacelog.html</Path>
    <Anchor>a1cc21838b30cf8f8370a7eb503651836</Anchor>
    <Abstract>Defines the various logging levels. </Abstract>
    <DeclaredIn>log.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__logLock__</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>log</Scope>
    </TokenIdentifier>
    <Path>namespacelog.html</Path>
    <Anchor>a251cea60e4e45c72304197364f745846</Anchor>
    <Abstract>The log that controls access to the output. </Abstract>
    <DeclaredIn>log.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>md_doc_IF1</Name>
      <APILanguage>markdown</APILanguage>
    </TokenIdentifier>
    <Path>md_doc__i_f1.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>SortSis</Name>
      <APILanguage>markdown</APILanguage>
    </TokenIdentifier>
    <Path>_sort_sis.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>SortIF1</Name>
      <APILanguage>markdown</APILanguage>
    </TokenIdentifier>
    <Path>_sort_i_f1.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>md_README</Name>
      <APILanguage>markdown</APILanguage>
    </TokenIdentifier>
    <Path>md__r_e_a_d_m_e.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>todo</Name>
      <APILanguage>unknown</APILanguage>
    </TokenIdentifier>
    <Path>todo.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>compiler</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>compiler</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler.html</Path>
    <Abstract>IGR Compiler. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>compiler::dot</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Abstract>IGR dot parser. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>subGraphHeader</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>aea31a1aceed8455ba7179e254a677d6c</Anchor>
    <Abstract>Add the attributes of the subgraph. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>subGraphFooter</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>a1f5178873440863fffb6ae47c7202667</Anchor>
    <Abstract>&amp;quot;close&amp;quot; the subgraph. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>portString</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>a2b165c8b0265f5f5d824b0bfc595588a</Anchor>
    <Abstract>Get a representation for a port. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ports</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>acaa819ccaaa232d873ce172287bd857a</Anchor>
    <Abstract>String representation of a port list. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inputList</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>a6df36fb8b1f135d7e646440e6adf39d1</Anchor>
    <Abstract>Get the portlist for the inputs of a node. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>outputList</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>a6a1175fd47928bf210540e06854f884d</Anchor>
    <Abstract>Get the portlist for the outputs of a node. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>nodeIdentifier</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>a7e29902b97989ad0da9f3d3c4055a0c4</Anchor>
    <Abstract>Identifier of the node. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>edgeStr</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>a22d69d4cfb87904a0baa28982d59e7aa</Anchor>
    <Abstract>Convert a connection to a string. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>nodeLabel</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>ae92a24a3e20437518443308493826e39</Anchor>
    <Abstract>Add the label of the node to the buffer. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>nodeLinks</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>aecd94322f518eca095440e929ff869f0</Anchor>
    <Abstract>Add all the outgoing edges of a node to the buffer. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>node</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>ad156d481575b1064cfe3673afb0760c0</Anchor>
    <Abstract>Write the information of a node to the buffer. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dotHeader</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>aa4eab18b90e883fddbf2b7367f654d7b</Anchor>
    <Abstract>Write general dot information. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dotFooter</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>a64ecb170a7342bba287d37909b9d47b2</Anchor>
    <Abstract>Close the dot graph. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getDot</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>aa1c58f873cee40263ac5a2c07fb617b5</Anchor>
    <Abstract>Create the dot string. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dotToFile</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>ab9fb1f388749ced3ba64ee867fae0920</Anchor>
    <Abstract>Get the dot representation and write it to a file. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>runDot</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::dot</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1dot.html</Path>
    <Anchor>ab8d86a047857d932d4a46bced06e74ba</Anchor>
    <Abstract>Convert the IGR graph to dot, save it, and run dot on this file. </Abstract>
    <DeclaredIn>dot.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>compiler::traverse</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>compiler::traverse</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1traverse.html</Path>
    <Abstract>IGR Traversals. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>traverseAll</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>compiler::traverse</Scope>
    </TokenIdentifier>
    <Path>namespacecompiler_1_1traverse.html</Path>
    <Anchor>a8e26de5b58a3972dc0f7a780f64889d4</Anchor>
    <Abstract>Traverse all the nodes in the program. </Abstract>
    <DeclaredIn>traverse.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>dvm</Scope>
    </TokenIdentifier>
    <Path>namespacedvm.html</Path>
    <Abstract>Dataflow Virtual Machine. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addOperationInstruction</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm</Scope>
    </TokenIdentifier>
    <Path>namespacedvm.html</Path>
    <Anchor>aab958de8f0a34977369e337af856cc0c</Anchor>
    <Abstract>Add an operation instruction. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addSink</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm</Scope>
    </TokenIdentifier>
    <Path>namespacedvm.html</Path>
    <Anchor>ae79b89566a5fa959017e1c4f4e2194e8</Anchor>
    <Abstract>Add a sink instruction. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addContextChange</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm</Scope>
    </TokenIdentifier>
    <Path>namespacedvm.html</Path>
    <Anchor>a82f3c258dc8312f18ca461a74247b584</Anchor>
    <Abstract>Add a context change instruction. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addContextRestore</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm</Scope>
    </TokenIdentifier>
    <Path>namespacedvm.html</Path>
    <Anchor>acd810468527bd761f08c4701a07d2bb7</Anchor>
    <Abstract>Add a context restore instruction. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addStopInstruction</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm</Scope>
    </TokenIdentifier>
    <Path>namespacedvm.html</Path>
    <Anchor>abe4bfce9e8136880a7dc8fcc58835bc7</Anchor>
    <Abstract>Add a stop instruction. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addDestination</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm</Scope>
    </TokenIdentifier>
    <Path>namespacedvm.html</Path>
    <Anchor>aec3ef29b6ff8be5daecd17e314959628</Anchor>
    <Abstract>Add a destination to a given instruction. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>start</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm</Scope>
    </TokenIdentifier>
    <Path>namespacedvm.html</Path>
    <Anchor>a98adedcf92f4a2d4c6e0a81d3e5e55ce</Anchor>
    <Abstract>Start program execution. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::context</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>dvm::context</Scope>
    </TokenIdentifier>
    <Path>namespacedvm_1_1context.html</Path>
    <Abstract>DVM Contexts. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::context::Context</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>dvm.context.Context</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1context_1_1_context.html</Path>
    <Abstract>DVM Context. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>hashPair</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.context.Context</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1context_1_1_context.html</Path>
    <Anchor>af5db1e55ff0acba8f825519d3e3144c6</Anchor>
    <Abstract>Generate a unique, integral identifier for a pair of non-negative integers. </Abstract>
    <DeclaredIn>context.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>unhashPair</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.context.Context</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1context_1_1_context.html</Path>
    <Anchor>a1157cb8a309b214ccb316a251bfcf624</Anchor>
    <Abstract>Unhashes the hash. </Abstract>
    <DeclaredIn>context.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::context::ContextCreator</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>dvm.context.ContextCreator</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1context_1_1_context_creator.html</Path>
    <Abstract>Context creator. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::contextMatcher</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>dvm::contextMatcher</Scope>
    </TokenIdentifier>
    <Path>namespacedvm_1_1context_matcher.html</Path>
    <Abstract>DVM context matcher. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::contextMatcher::ContextMatcher</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>dvm.contextMatcher.ContextMatcher</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1context_matcher_1_1_context_matcher.html</Path>
    <Abstract>DVM Context matcher. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__init__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.contextMatcher.ContextMatcher</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1context_matcher_1_1_context_matcher.html</Path>
    <Anchor>a4d2281372583ee88ca2daa4564337594</Anchor>
    <Abstract>Initialize a context matcher. </Abstract>
    <DeclaredIn>contextMatcher.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>checkKey</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.contextMatcher.ContextMatcher</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1context_matcher_1_1_context_matcher.html</Path>
    <Anchor>a8d00ef4127629d689f9ab10c616ef4ba</Anchor>
    <Abstract>See if a given key is already a part of the tokens we are matching. </Abstract>
    <DeclaredIn>contextMatcher.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>updateKeyArr</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.contextMatcher.ContextMatcher</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1context_matcher_1_1_context_matcher.html</Path>
    <Anchor>a3f1bfce4fb89f0a3e503863554b55508</Anchor>
    <Abstract>Update the token array for a key This method assumes that there is an array for the given key...</Abstract>
    <DeclaredIn>contextMatcher.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isKeyReady</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.contextMatcher.ContextMatcher</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1context_matcher_1_1_context_matcher.html</Path>
    <Anchor>a88b64361987a557db02ed2dcd7484286</Anchor>
    <Abstract>See if all the input tokens are present for a given key. </Abstract>
    <DeclaredIn>contextMatcher.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>executeKey</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.contextMatcher.ContextMatcher</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1context_matcher_1_1_context_matcher.html</Path>
    <Anchor>a2df283e910779817fa051722226d7cbd</Anchor>
    <Abstract>Add the tokens for key to the scheduler. </Abstract>
    <DeclaredIn>contextMatcher.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>add</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.contextMatcher.ContextMatcher</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1context_matcher_1_1_context_matcher.html</Path>
    <Anchor>abd187cf46cf6bd0dccc3147b2f9b8742</Anchor>
    <Abstract>Add a token to the matcher. </Abstract>
    <DeclaredIn>contextMatcher.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>tokens</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>dvm.contextMatcher.ContextMatcher</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1context_matcher_1_1_context_matcher.html</Path>
    <Anchor>a9f97716dee81761787941166ad1d50f7</Anchor>
    <Abstract>Dictionary that contains the tokens for all the keys. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>core</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>dvm.contextMatcher.ContextMatcher</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1context_matcher_1_1_context_matcher.html</Path>
    <Anchor>a9d1befaa13427ca6d0526b2c92071c58</Anchor>
    <Abstract>Reference to the DVM::Core. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::dispatcher</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>dvm::dispatcher</Scope>
    </TokenIdentifier>
    <Path>namespacedvm_1_1dispatcher.html</Path>
    <Abstract>DVM token dispatcher. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::dispatcher::TokenDispatcher</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>dvm.dispatcher.TokenDispatcher</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1dispatcher_1_1_token_dispatcher.html</Path>
    <Abstract>Token Dispatcher. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>checkSpecial</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.dispatcher.TokenDispatcher</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1dispatcher_1_1_token_dispatcher.html</Path>
    <Anchor>a944b3ec91f5ff3ccdd0b48e7624e4d92</Anchor>
    <Abstract>See if a given token is a special token. </Abstract>
    <DeclaredIn>dispatcher.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::instruction</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>dvm::instruction</Scope>
    </TokenIdentifier>
    <Path>namespacedvm_1_1instruction.html</Path>
    <Abstract>DVM instruction definitions. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::instruction::AbstractInstruction</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Abstract>General DVM instruction. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>setKey</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>ad13338bed228cc8001995f9f79eb85e0</Anchor>
    <Abstract>Set the instruction address. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__str__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>abc0ffb3db1a46b74c6d76b053fa602e9</Anchor>
    <Abstract>Return a string representation of this instruction. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>execute</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>a8ef96bc55e87e6105af6d2aa2811c5ca</Anchor>
    <Abstract>Execute an instruction with a given input and a core. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>needsMatcher</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>ad622b495c431658bef42f0a9b9778674</Anchor>
    <Abstract>See if an instruction requires context matching. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::instruction::StaticInstruction</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>dvm.instruction.StaticInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_static_instruction.html</Path>
    <Abstract>A static instruction will always send it&amp;#39;s output to the same instructions. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addDestination</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.StaticInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_static_instruction.html</Path>
    <Anchor>abc4ec03eb29e44cd840cfe1f09c05472</Anchor>
    <Abstract>Add a destination to this instruction. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>sendDatum</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.StaticInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_static_instruction.html</Path>
    <Anchor>a993ce2343d71635f06291471a8a8646e</Anchor>
    <Abstract>Send a datum to any destination of a given output port. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>setKey</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>ad13338bed228cc8001995f9f79eb85e0</Anchor>
    <Abstract>Set the instruction address. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__str__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>abc0ffb3db1a46b74c6d76b053fa602e9</Anchor>
    <Abstract>Return a string representation of this instruction. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>execute</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>a8ef96bc55e87e6105af6d2aa2811c5ca</Anchor>
    <Abstract>Execute an instruction with a given input and a core. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>needsMatcher</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>ad622b495c431658bef42f0a9b9778674</Anchor>
    <Abstract>See if an instruction requires context matching. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::instruction::OperationInstruction</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>dvm.instruction.OperationInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_operation_instruction.html</Path>
    <Abstract>An operation instruction defines a single operation on all of it&amp;#39;s inputs. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>sendResults</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.OperationInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_operation_instruction.html</Path>
    <Anchor>a3a873701bceb18e06ddcce119158e52d</Anchor>
    <Abstract>Send results to the relevant destinations. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addDestination</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.StaticInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_static_instruction.html</Path>
    <Anchor>abc4ec03eb29e44cd840cfe1f09c05472</Anchor>
    <Abstract>Add a destination to this instruction. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>sendDatum</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.StaticInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_static_instruction.html</Path>
    <Anchor>a993ce2343d71635f06291471a8a8646e</Anchor>
    <Abstract>Send a datum to any destination of a given output port. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>setKey</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>ad13338bed228cc8001995f9f79eb85e0</Anchor>
    <Abstract>Set the instruction address. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__str__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>abc0ffb3db1a46b74c6d76b053fa602e9</Anchor>
    <Abstract>Return a string representation of this instruction. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>execute</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>a8ef96bc55e87e6105af6d2aa2811c5ca</Anchor>
    <Abstract>Execute an instruction with a given input and a core. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>needsMatcher</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>ad622b495c431658bef42f0a9b9778674</Anchor>
    <Abstract>See if an instruction requires context matching. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::instruction::Sink</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>dvm.instruction.Sink</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_sink.html</Path>
    <Abstract>Sink instruction. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addDestination</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.StaticInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_static_instruction.html</Path>
    <Anchor>abc4ec03eb29e44cd840cfe1f09c05472</Anchor>
    <Abstract>Add a destination to this instruction. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>sendDatum</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.StaticInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_static_instruction.html</Path>
    <Anchor>a993ce2343d71635f06291471a8a8646e</Anchor>
    <Abstract>Send a datum to any destination of a given output port. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>setKey</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>ad13338bed228cc8001995f9f79eb85e0</Anchor>
    <Abstract>Set the instruction address. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__str__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>abc0ffb3db1a46b74c6d76b053fa602e9</Anchor>
    <Abstract>Return a string representation of this instruction. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>execute</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>a8ef96bc55e87e6105af6d2aa2811c5ca</Anchor>
    <Abstract>Execute an instruction with a given input and a core. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>needsMatcher</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>ad622b495c431658bef42f0a9b9778674</Anchor>
    <Abstract>See if an instruction requires context matching. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::instruction::ContextChange</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>dvm.instruction.ContextChange</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_context_change.html</Path>
    <Abstract>Represents a context change in the program. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__init__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.ContextChange</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_context_change.html</Path>
    <Anchor>ac1b2ac224d516b33839e441d737132ef</Anchor>
    <Abstract>Initialize a context change instruction. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>setKey</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>ad13338bed228cc8001995f9f79eb85e0</Anchor>
    <Abstract>Set the instruction address. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__str__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>abc0ffb3db1a46b74c6d76b053fa602e9</Anchor>
    <Abstract>Return a string representation of this instruction. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>execute</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>a8ef96bc55e87e6105af6d2aa2811c5ca</Anchor>
    <Abstract>Execute an instruction with a given input and a core. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>needsMatcher</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>ad622b495c431658bef42f0a9b9778674</Anchor>
    <Abstract>See if an instruction requires context matching. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::instruction::ContextRestore</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>dvm.instruction.ContextRestore</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_context_restore.html</Path>
    <Abstract>Represents the restoration of context. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>setKey</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>ad13338bed228cc8001995f9f79eb85e0</Anchor>
    <Abstract>Set the instruction address. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__str__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>abc0ffb3db1a46b74c6d76b053fa602e9</Anchor>
    <Abstract>Return a string representation of this instruction. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>execute</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>a8ef96bc55e87e6105af6d2aa2811c5ca</Anchor>
    <Abstract>Execute an instruction with a given input and a core. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>needsMatcher</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>ad622b495c431658bef42f0a9b9778674</Anchor>
    <Abstract>See if an instruction requires context matching. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::instruction::StopInstruction</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>dvm.instruction.StopInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_stop_instruction.html</Path>
    <Abstract>Represents the end of the program. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>setKey</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>ad13338bed228cc8001995f9f79eb85e0</Anchor>
    <Abstract>Set the instruction address. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__str__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>abc0ffb3db1a46b74c6d76b053fa602e9</Anchor>
    <Abstract>Return a string representation of this instruction. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>execute</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>a8ef96bc55e87e6105af6d2aa2811c5ca</Anchor>
    <Abstract>Execute an instruction with a given input and a core. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>needsMatcher</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.instruction.AbstractInstruction</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1instruction_1_1_abstract_instruction.html</Path>
    <Anchor>ad622b495c431658bef42f0a9b9778674</Anchor>
    <Abstract>See if an instruction requires context matching. </Abstract>
    <DeclaredIn>instruction.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::memory</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>dvm::memory</Scope>
    </TokenIdentifier>
    <Path>namespacedvm_1_1memory.html</Path>
    <Abstract>DVM instruction memory. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>memory</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm::memory</Scope>
    </TokenIdentifier>
    <Path>namespacedvm_1_1memory.html</Path>
    <Anchor>a4f967c1cc9fba0a6944d5ad3acfdf23b</Anchor>
    <Abstract>Get a reference to the instruction memory. </Abstract>
    <DeclaredIn>memory.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>reset</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm::memory</Scope>
    </TokenIdentifier>
    <Path>namespacedvm_1_1memory.html</Path>
    <Anchor>a8185b97612cbd51ad34a78aa82293978</Anchor>
    <Abstract>Delete all the contents of the instruction memory. </Abstract>
    <DeclaredIn>memory.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>get</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm::memory</Scope>
    </TokenIdentifier>
    <Path>namespacedvm_1_1memory.html</Path>
    <Anchor>aaa309903cc32fe7a8a4ab0a2a370856b</Anchor>
    <Abstract>Get an instruction from the main memory. </Abstract>
    <DeclaredIn>memory.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>add</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm::memory</Scope>
    </TokenIdentifier>
    <Path>namespacedvm_1_1memory.html</Path>
    <Anchor>a77c9b4a570656fe7004e398d4cfa36aa</Anchor>
    <Abstract>Add an instruction to the main memory. </Abstract>
    <DeclaredIn>memory.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>needsMatcher</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm::memory</Scope>
    </TokenIdentifier>
    <Path>namespacedvm_1_1memory.html</Path>
    <Anchor>aae240e1a45decaa89947497faf0175da</Anchor>
    <Abstract>See if an instruction needs to pass the matcher Instructions that require a context manager are store...</Abstract>
    <DeclaredIn>memory.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__MEMORY__</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>dvm::memory</Scope>
    </TokenIdentifier>
    <Path>namespacedvm_1_1memory.html</Path>
    <Anchor>a2b1f2d9a35d3c9b79a0df2e172fe0410</Anchor>
    <Abstract>Main instance of the instruction memory. </Abstract>
    <DeclaredIn>memory.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::memory::InstructionMemory</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>dvm.memory.InstructionMemory</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1memory_1_1_instruction_memory.html</Path>
    <Abstract>The Instruction memory stores all of the instructions in the program. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getInstruction</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.memory.InstructionMemory</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1memory_1_1_instruction_memory.html</Path>
    <Anchor>a0ec667fe6601f41175d1283f702b6182</Anchor>
    <Abstract>Get a single instruction from memory. </Abstract>
    <DeclaredIn>memory.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>reserveStandardSlot</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.memory.InstructionMemory</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1memory_1_1_instruction_memory.html</Path>
    <Anchor>ad1387950bfe8247638dea45db8e033a4</Anchor>
    <Abstract>Reserve a slot for an instruction that does not require any context matching. </Abstract>
    <DeclaredIn>memory.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>reserveMatcherSlot</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.memory.InstructionMemory</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1memory_1_1_instruction_memory.html</Path>
    <Anchor>a9c3ab29bff88cf1d371fd3b97b24626c</Anchor>
    <Abstract>Reserve a slot for an instruction that requires context matching. </Abstract>
    <DeclaredIn>memory.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>add</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.memory.InstructionMemory</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1memory_1_1_instruction_memory.html</Path>
    <Anchor>a8be039d30c80a42b5b8da394cba6801e</Anchor>
    <Abstract>Add an instruction to the memory. </Abstract>
    <DeclaredIn>memory.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>get</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.memory.InstructionMemory</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1memory_1_1_instruction_memory.html</Path>
    <Anchor>a177760f419596e63b3b2e61a0fd4f65a</Anchor>
    <Abstract>Get an instruction from memory. </Abstract>
    <DeclaredIn>memory.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::runtime</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>dvm::runtime</Scope>
    </TokenIdentifier>
    <Path>namespacedvm_1_1runtime.html</Path>
    <Abstract>DVM runtime core. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>start</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>dvm::runtime</Scope>
    </TokenIdentifier>
    <Path>namespacedvm_1_1runtime.html</Path>
    <Anchor>a0d16ebb214942a98dcc910fd0e4b88f5</Anchor>
    <Abstract>Initialize the cores, and start program execution. </Abstract>
    <DeclaredIn>runtime.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::runtime::Core</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>dvm.runtime.Core</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1runtime_1_1_core.html</Path>
    <Abstract>Runtime core. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__init__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.runtime.Core</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1runtime_1_1_core.html</Path>
    <Anchor>a3b87aa3075c9ce4d572e9abfb981571b</Anchor>
    <Abstract>Initialize a core. </Abstract>
    <DeclaredIn>runtime.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__str__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.runtime.Core</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1runtime_1_1_core.html</Path>
    <Anchor>af3b12ba48780333647a5ada2510a416f</Anchor>
    <Abstract>String representation of a core. </Abstract>
    <DeclaredIn>runtime.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__eq__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.runtime.Core</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1runtime_1_1_core.html</Path>
    <Anchor>a411f6c154e1f55c313f42d1e54364aec</Anchor>
    <Abstract>See if 2 cores are equal. </Abstract>
    <DeclaredIn>runtime.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>add</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.runtime.Core</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1runtime_1_1_core.html</Path>
    <Anchor>ade86bd994a3a4c9f1c45ef616c55840e</Anchor>
    <Abstract>Add a token to the inbox of a core. </Abstract>
    <DeclaredIn>runtime.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>start</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.runtime.Core</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1runtime_1_1_core.html</Path>
    <Anchor>aad417b3e813abf903f4f57dfd3605c1d</Anchor>
    <Abstract>Set up the multiprocessing elements of the core and start the runtime. </Abstract>
    <DeclaredIn>runtime.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>stop</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.runtime.Core</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1runtime_1_1_core.html</Path>
    <Anchor>aa4d8eff6c4e3ebfe61d2e1125d6dc89f</Anchor>
    <Abstract>Stop the current core. </Abstract>
    <DeclaredIn>runtime.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>memory</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>dvm.runtime.Core</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1runtime_1_1_core.html</Path>
    <Anchor>a0a39cbab7298c32cfa3f839f0082f978</Anchor>
    <Abstract>Instruction memory. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>identifier</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>dvm.runtime.Core</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1runtime_1_1_core.html</Path>
    <Anchor>a47ab82ec1820720aac891504cb234abf</Anchor>
    <Abstract>Identifier of this core. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>active</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>dvm.runtime.Core</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1runtime_1_1_core.html</Path>
    <Anchor>a94b351c6a46272497c9cd387e49b4948</Anchor>
    <Abstract>See if this core is running. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inbox</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>dvm.runtime.Core</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1runtime_1_1_core.html</Path>
    <Anchor>aba7ab9d41551b175ce628d107045dfdd</Anchor>
    <Abstract>Message Queue of this core. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cores</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>dvm.runtime.Core</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1runtime_1_1_core.html</Path>
    <Anchor>a9f46eb0a03960df425275cfe4f972c77</Anchor>
    <Abstract>Message Queues of the other cores. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>contextCreator</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>dvm.runtime.Core</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1runtime_1_1_core.html</Path>
    <Anchor>ac9efb1b5cb6e946f299600092981538a</Anchor>
    <Abstract>Context creator for this core. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>tokenCreator</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>dvm.runtime.Core</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1runtime_1_1_core.html</Path>
    <Anchor>ae0abd463937aea3492698064be5eb79e</Anchor>
    <Abstract>Token creator for this core. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dispatcher</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>dvm.runtime.Core</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1runtime_1_1_core.html</Path>
    <Anchor>ae86eae7bb743fe5ad5856b840fa70268</Anchor>
    <Abstract>Token dispatcher for this core. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>scheduler</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>dvm.runtime.Core</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1runtime_1_1_core.html</Path>
    <Anchor>aabb8fee3e1fb8c2f239eb14f0da3bc5a</Anchor>
    <Abstract>Scheduler for this core. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>matcher</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>dvm.runtime.Core</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1runtime_1_1_core.html</Path>
    <Anchor>aa9742ca875188305fb7facd77e7ed5c5</Anchor>
    <Abstract>Context matcher for this core. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::scheduler</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>dvm::scheduler</Scope>
    </TokenIdentifier>
    <Path>namespacedvm_1_1scheduler.html</Path>
    <Abstract>DVM instruction scheduler. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::scheduler::Scheduler</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>dvm.scheduler.Scheduler</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1scheduler_1_1_scheduler.html</Path>
    <Abstract>DVM Scheduler. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::token</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>dvm::token</Scope>
    </TokenIdentifier>
    <Path>namespacedvm_1_1token.html</Path>
    <Abstract>DVM Tagged tokens. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::token::Token</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>dvm.token.Token</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1token_1_1_token.html</Path>
    <Abstract>Represents a DVM token. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::token::AbstractTag</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>dvm.token.AbstractTag</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1token_1_1_abstract_tag.html</Path>
    <Abstract>Represents a tag. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::token::Tag</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>dvm.token.Tag</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1token_1_1_tag.html</Path>
    <Abstract>Standard tag. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::token::STag</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>dvm.token.STag</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1token_1_1_s_tag.html</Path>
    <Abstract>Special Tag. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::token::StopTag</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>dvm.token.StopTag</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1token_1_1_stop_tag.html</Path>
    <Abstract>Stop Tag. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::tokenCreator</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>dvm::tokenCreator</Scope>
    </TokenIdentifier>
    <Path>namespacedvm_1_1token_creator.html</Path>
    <Abstract>DVM token creator. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dvm::tokenCreator::TokenCreator</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>dvm.tokenCreator.TokenCreator</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1token_creator_1_1_token_creator.html</Path>
    <Abstract>DVM Token creator. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>simpleToken</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.tokenCreator.TokenCreator</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1token_creator_1_1_token_creator.html</Path>
    <Anchor>a39ef14091d4c45021cdc192f06fe0e19</Anchor>
    <Abstract>Create a simple token, with a known destination. </Abstract>
    <DeclaredIn>tokenCreator.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>changeContext</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.tokenCreator.TokenCreator</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1token_creator_1_1_token_creator.html</Path>
    <Anchor>add23e9ae708db73f125b2d336baed285</Anchor>
    <Abstract>Change the context of a token. </Abstract>
    <DeclaredIn>tokenCreator.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>restoreContext</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>dvm.tokenCreator.TokenCreator</Scope>
    </TokenIdentifier>
    <Path>classdvm_1_1token_creator_1_1_token_creator.html</Path>
    <Anchor>adf17053d5c68bf377715fa9271349606</Anchor>
    <Abstract>Restore the old context of a token. </Abstract>
    <DeclaredIn>tokenCreator.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>if1parser</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>if1parser</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser.html</Path>
    <Abstract>DVM IF1 Parser. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>parseFile</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser.html</Path>
    <Anchor>a0dd29707e7f3446442354f71fd89ea03</Anchor>
    <Abstract>Parses an IF1 file. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>if1parser::compound</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>if1parser::compound</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1compound.html</Path>
    <Abstract>Compound node reference. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__COMPOUNDS__</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>if1parser::compound</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1compound.html</Path>
    <Anchor>a797383d1cc69393e996bfa86123543dd</Anchor>
    <Abstract>Various IGR compound nodes. </Abstract>
    <DeclaredIn>compound.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>if1parser::edge</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>if1parser::edge</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1edge.html</Path>
    <Abstract>Parse edges and literalss. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>parseEdge</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::edge</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1edge.html</Path>
    <Anchor>a9559e91a84e4c6938465015a28a21088</Anchor>
    <Abstract>Parse an IF1 edge. </Abstract>
    <DeclaredIn>edge.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>parseLiteral</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::edge</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1edge.html</Path>
    <Anchor>a92dd2e5c05f3f871cac4da1b86c65cb6</Anchor>
    <Abstract>Parse an IF1 literal. </Abstract>
    <DeclaredIn>edge.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>if1parser::environment</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Abstract>Node lookup and scoping rules. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>scope</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>ac3d3b545f999512679672bf888eba1b0</Anchor>
    <Abstract>Create a new scope and push it on top of the stack. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>scopeCompound</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>a9c6dbe85da553aec7e1c56c5e8541dd3</Anchor>
    <Abstract>Create a new compound scope and push it on top of the stack. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>popScope</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>a55892a8042f043de0dc88bfc69c32043</Anchor>
    <Abstract>Remove the current scope. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getNode</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>a96c29b707f105852877f2f57124309d1</Anchor>
    <Abstract>Get the node with label in the current scope. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addNode</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>a85356c8a9cdc471a3629c9ef96a30f15</Anchor>
    <Abstract>Add node with label to the current scope. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getSubGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>a14455ac1a0ea0244fba8ab51ca665784</Anchor>
    <Abstract>Get the subgraph of the current scope. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addSubGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>a73edb1959ff472959bc7c95925c0f2f8</Anchor>
    <Abstract>Add a subgraph to the compound scope. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getSubGraphs</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>a265a80560eda3b9fca53f37793882e6e</Anchor>
    <Abstract>Get the subgraphs. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isCompound</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>a0c850780cfb126dd8744cedbe3bf876d</Anchor>
    <Abstract>Are we currently in a compound node? </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>enterComp</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>aff6442e36aba86f0088dc3161abe3719</Anchor>
    <Abstract>Enter a compound node. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>exitComp</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>ae609458a57295c6f7730d4dc0f590b77</Anchor>
    <Abstract>Exit a compound node. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__STACK__</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>a1a50b4e04442e44e141d765e027c574f</Anchor>
    <Abstract>A stack with the global scope at the bottom, and the current scope at the top. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__COMP_LEVEL__</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>if1parser::environment</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1environment.html</Path>
    <Anchor>a15eaacefeb3026ee420764029bb3c20a</Anchor>
    <Abstract>Keeps track of the level of depth w.r.t. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>if1parser::environment::Scope</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>if1parser.environment.Scope</Scope>
    </TokenIdentifier>
    <Path>classif1parser_1_1environment_1_1_scope.html</Path>
    <Abstract>Single part of the scope stack. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__init__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>if1parser.environment.Scope</Scope>
    </TokenIdentifier>
    <Path>classif1parser_1_1environment_1_1_scope.html</Path>
    <Anchor>a173dfa8cf381a6acb0cbbe5855b21363</Anchor>
    <Abstract>Create a scope belonging to a subgraph.s By convention, the subgraph can always be found at label 0...</Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addNode</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>if1parser.environment.Scope</Scope>
    </TokenIdentifier>
    <Path>classif1parser_1_1environment_1_1_scope.html</Path>
    <Anchor>a463490a0763f3457b00c7752b6cdcd5d</Anchor>
    <Abstract>Add a node to the scope. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getNode</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>if1parser.environment.Scope</Scope>
    </TokenIdentifier>
    <Path>classif1parser_1_1environment_1_1_scope.html</Path>
    <Anchor>a0016f7558247f74920fe0ec2d17a3154</Anchor>
    <Abstract>Get a node from the scope. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getSubGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>if1parser.environment.Scope</Scope>
    </TokenIdentifier>
    <Path>classif1parser_1_1environment_1_1_scope.html</Path>
    <Anchor>ae39e39b27fa50b2169ed42b154224fb8</Anchor>
    <Abstract>Get the subgraph of the scope. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>if1parser::environment::CompoundScope</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>if1parser.environment.CompoundScope</Scope>
    </TokenIdentifier>
    <Path>classif1parser_1_1environment_1_1_compound_scope.html</Path>
    <Abstract>Single part of the scope stack. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addSubGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>if1parser.environment.CompoundScope</Scope>
    </TokenIdentifier>
    <Path>classif1parser_1_1environment_1_1_compound_scope.html</Path>
    <Anchor>ac790db6bde935d1e37bd0d8a33e657c8</Anchor>
    <Abstract>Add a graph to the list of subgraphs. </Abstract>
    <DeclaredIn>environment.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>if1parser::graph</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>if1parser::graph</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1graph.html</Path>
    <Abstract>Node parser. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>parseSubGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::graph</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1graph.html</Path>
    <Anchor>a89697113e8095d64609a253f171b2851</Anchor>
    <Abstract>Parse a standard subgraph. </Abstract>
    <DeclaredIn>graph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>parseCompoundSubGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::graph</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1graph.html</Path>
    <Anchor>a2bee103d1fa968453a1d358d694b77e0</Anchor>
    <Abstract>Parse a subgraph of a compound node. </Abstract>
    <DeclaredIn>graph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>parseGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::graph</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1graph.html</Path>
    <Anchor>ad0dd06cbdd5630636069753749ed2e60</Anchor>
    <Abstract>Determine which kind of subgraph we are dealing with. </Abstract>
    <DeclaredIn>graph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>parseCompoundStart</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::graph</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1graph.html</Path>
    <Anchor>a3f57a04f39830c78e2e9665f522331eb</Anchor>
    <Abstract>Parse the start of a compound node. </Abstract>
    <DeclaredIn>graph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>if1parser::parser</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>if1parser::parser</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1parser.html</Path>
    <Abstract>Main parser loop. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>skipLine</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::parser</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1parser.html</Path>
    <Anchor>a2d4a84452234eb18b18bf7734f82310d</Anchor>
    <Abstract>Skip a line #. </Abstract>
    <DeclaredIn>parser.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>parseLine</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::parser</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1parser.html</Path>
    <Anchor>abc99e0a3cd70f9aac6ea3878e52bdfde</Anchor>
    <Abstract>Parse a single if1 line. </Abstract>
    <DeclaredIn>parser.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>parseString</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::parser</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1parser.html</Path>
    <Anchor>aeccd6ca9f1a71f3d78943ecbba250907</Anchor>
    <Abstract>Parse a complete IF1 string. </Abstract>
    <DeclaredIn>parser.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>parseFile</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::parser</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1parser.html</Path>
    <Anchor>ae59b6559232a12495c5a8fc0f9c317cb</Anchor>
    <Abstract>Parses an IF1 file. </Abstract>
    <DeclaredIn>parser.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__FUNCTIONS__</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>if1parser::parser</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1parser.html</Path>
    <Anchor>acee573307f5a5a1c1257f0d46cdce19f</Anchor>
    <Abstract>Parser values and the function to call when they are encountered. </Abstract>
    <DeclaredIn>parser.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>if1parser::tools</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>if1parser::tools</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1tools.html</Path>
    <Abstract>Parser Frontend. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>warning</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::tools</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1tools.html</Path>
    <Anchor>afbb6fe73c05c31cda4a0912d0029f382</Anchor>
    <Abstract>Print a warning to stdout. </Abstract>
    <DeclaredIn>tools.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>error</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::tools</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1tools.html</Path>
    <Anchor>a1fb18a2807bc9956f256b59f78d87fbb</Anchor>
    <Abstract>Print an error to stdout. </Abstract>
    <DeclaredIn>tools.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>if1parser::type</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>if1parser::type</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1type.html</Path>
    <Abstract>Type parser. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getType</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>if1parser::type</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1type.html</Path>
    <Anchor>a51af0e361088d1735780e23103356f0e</Anchor>
    <Abstract>Get a type from the pool. </Abstract>
    <DeclaredIn>type.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>_type_codes</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>if1parser::type</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1type.html</Path>
    <Anchor>a9f51012fcb99a6061d1d3c80d6132bdd</Anchor>
    <Abstract>The function that is needed to parse a given idx. </Abstract>
    <DeclaredIn>type.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>_basic_types</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>if1parser::type</Scope>
    </TokenIdentifier>
    <Path>namespaceif1parser_1_1type.html</Path>
    <Anchor>ad14723757fb16b37b92cc78718733c46</Anchor>
    <Abstract>Basic type codes and the python types to match them. </Abstract>
    <DeclaredIn>type.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>if1parser::type::_UnknownType</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>if1parser.type._UnknownType</Scope>
    </TokenIdentifier>
    <Path>classif1parser_1_1type_1_1___unknown_type.html</Path>
    <Abstract>Represents any possible type. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>if1parser::type::_BasicType</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>if1parser.type._BasicType</Scope>
    </TokenIdentifier>
    <Path>classif1parser_1_1type_1_1___basic_type.html</Path>
    <Abstract>Represents one of the basic IF1 types. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>if1parser::type::_ContainerType</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>if1parser.type._ContainerType</Scope>
    </TokenIdentifier>
    <Path>classif1parser_1_1type_1_1___container_type.html</Path>
    <Abstract>Wrapper around a container that contains a single base type (such as an array) </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>if1parser::type::_CombinedType</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>if1parser.type._CombinedType</Scope>
    </TokenIdentifier>
    <Path>classif1parser_1_1type_1_1___combined_type.html</Path>
    <Abstract>Wrapper around a combined type that contains multiple base types. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>if1parser::type::_PointerType</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>if1parser.type._PointerType</Scope>
    </TokenIdentifier>
    <Path>classif1parser_1_1type_1_1___pointer_type.html</Path>
    <Abstract>Wrapper around a pointer to the first element of a combined type. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>if1parser::type::_FunctionType</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>if1parser.type._FunctionType</Scope>
    </TokenIdentifier>
    <Path>classif1parser_1_1type_1_1___function_type.html</Path>
    <Abstract>Wrapper around a function type. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>if1parser::type::_TypePool</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>if1parser.type._TypePool</Scope>
    </TokenIdentifier>
    <Path>classif1parser_1_1type_1_1___type_pool.html</Path>
    <Abstract>Store all the encountered types. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>igr</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>igr</Scope>
    </TokenIdentifier>
    <Path>namespaceigr.html</Path>
    <Abstract>DVM Intermediate Graph Representation. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getSubGraphs</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr</Scope>
    </TokenIdentifier>
    <Path>namespaceigr.html</Path>
    <Anchor>a5f6af71dfd54044f478676514a3601aa</Anchor>
    <Abstract>Get a list of all the non-compound subgraphs in the program. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getSubGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr</Scope>
    </TokenIdentifier>
    <Path>namespaceigr.html</Path>
    <Anchor>a7179cb2c7d63947e8b423900b5dae82c</Anchor>
    <Abstract>Get a subgraph by name. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>createGeneralSubGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr</Scope>
    </TokenIdentifier>
    <Path>namespaceigr.html</Path>
    <Anchor>afbec9b955b6149a93149906f49cd2799</Anchor>
    <Abstract>Create a new subgraph. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>createSubGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr</Scope>
    </TokenIdentifier>
    <Path>namespaceigr.html</Path>
    <Anchor>a9b6d2c8d74c030f5afbad3c4ab866bce</Anchor>
    <Abstract>Create a subgraph and add it to the program graph. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>createCompoundSubGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr</Scope>
    </TokenIdentifier>
    <Path>namespaceigr.html</Path>
    <Anchor>aa6fd9ac3ba0d7cb2dfa515877dbf31e6</Anchor>
    <Abstract>Create a subgraph for a compound node. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>createNode</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr</Scope>
    </TokenIdentifier>
    <Path>namespaceigr.html</Path>
    <Anchor>a4c219a3f0d67516d3d7ecf9fbf1a3f1c</Anchor>
    <Abstract>Create a node, add it to it&amp;#39;s subgraph and return it. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>createOperationNode</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr</Scope>
    </TokenIdentifier>
    <Path>namespaceigr.html</Path>
    <Anchor>a9bf009f469c784d09bcf69d92fd08c57</Anchor>
    <Abstract>Create an operation node. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>createCompoundNode</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr</Scope>
    </TokenIdentifier>
    <Path>namespaceigr.html</Path>
    <Anchor>af62b226668dfc5dda0c584678f0fde90</Anchor>
    <Abstract>Create a Compound node. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>createCallNode</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr</Scope>
    </TokenIdentifier>
    <Path>namespaceigr.html</Path>
    <Anchor>a78ca4c3daf66bbf0171ae173dcd65bea</Anchor>
    <Abstract>Create a call node. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addLiteral</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr</Scope>
    </TokenIdentifier>
    <Path>namespaceigr.html</Path>
    <Anchor>a725e68f9b33824563a9f1ab374bf05c4</Anchor>
    <Abstract>Add a literal to a port. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>connect</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr</Scope>
    </TokenIdentifier>
    <Path>namespaceigr.html</Path>
    <Anchor>a74d7dd97190a3e48b8109e86786bf283</Anchor>
    <Abstract>Connect 2 ports with an implicit edge. </Abstract>
    <DeclaredIn>__init__.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>igr::graph</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>igr::graph</Scope>
    </TokenIdentifier>
    <Path>namespaceigr_1_1graph.html</Path>
    <Abstract>Complete program. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addSubGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr::graph</Scope>
    </TokenIdentifier>
    <Path>namespaceigr_1_1graph.html</Path>
    <Anchor>af34fc9690d77ea1afbb8ec9461c20d82</Anchor>
    <Abstract>Add a subgraph to the program. </Abstract>
    <DeclaredIn>graph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>bindName</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr::graph</Scope>
    </TokenIdentifier>
    <Path>namespaceigr_1_1graph.html</Path>
    <Anchor>a806e534c157fd842185841c1c9850473</Anchor>
    <Abstract>Add a subgraph to a given name. </Abstract>
    <DeclaredIn>graph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getSubGraphs</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr::graph</Scope>
    </TokenIdentifier>
    <Path>namespaceigr_1_1graph.html</Path>
    <Anchor>a88c9b06d2921992d38875658249813bc</Anchor>
    <Abstract>Get a list of all the non-compound subgraphs in the program. </Abstract>
    <DeclaredIn>graph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getSubGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr::graph</Scope>
    </TokenIdentifier>
    <Path>namespaceigr_1_1graph.html</Path>
    <Anchor>a9be3a51d4d501a7f52b1747d2ae46b03</Anchor>
    <Abstract>Get a subgraph by name. </Abstract>
    <DeclaredIn>graph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__SUBGRAPHS__</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>igr::graph</Scope>
    </TokenIdentifier>
    <Path>namespaceigr_1_1graph.html</Path>
    <Anchor>afdb8217d8e81b26a0c24ed2d8025d3d5</Anchor>
    <Abstract>All of the functions in the program. </Abstract>
    <DeclaredIn>graph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__FUNCTION_NAMES__</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>igr::graph</Scope>
    </TokenIdentifier>
    <Path>namespaceigr_1_1graph.html</Path>
    <Anchor>a9b1232f8e4181818a8d8a2add2ae9639</Anchor>
    <Abstract>The function names, combined with the subgraph they map to. </Abstract>
    <DeclaredIn>graph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>igr::literal</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>igr::literal</Scope>
    </TokenIdentifier>
    <Path>namespaceigr_1_1literal.html</Path>
    <Abstract>Literal definitions. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>igr::literal::Literal</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>igr.literal.Literal</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1literal_1_1_literal.html</Path>
    <Abstract>Literal. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__init__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.literal.Literal</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1literal_1_1_literal.html</Path>
    <Anchor>ae814e6d82b9fcf48b274cb8eca6d8bf0</Anchor>
    <Abstract>Create a new literal. </Abstract>
    <DeclaredIn>literal.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isPort</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.literal.Literal</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1literal_1_1_literal.html</Path>
    <Anchor>a82a760ccb0096d63113fbc475c0e0a6e</Anchor>
    <Abstract>See if this is a port (mainly for traversal) </Abstract>
    <DeclaredIn>literal.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>igr::node</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>igr::node</Scope>
    </TokenIdentifier>
    <Path>namespaceigr_1_1node.html</Path>
    <Abstract>Node definitions. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getKey</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>igr::node</Scope>
    </TokenIdentifier>
    <Path>namespaceigr_1_1node.html</Path>
    <Anchor>af484daef5e53d09cd12bff5103857432</Anchor>
    <Abstract>Generate unique id. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>igr::node::Node</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Abstract>Standard node. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__init__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a597304574e02b2556ce6a4137ec2c78f</Anchor>
    <Abstract>Create a new node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__str__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a89a5287e555372e46085822ec5cfbbad</Anchor>
    <Abstract>Create a printable version of the node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getInputPort</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>aa899fb251fb3bb18b430b6bbc73f4325</Anchor>
    <Abstract>Gets an input port. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getOutputPort</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a1c00ce1173ac404ef762671503122c19</Anchor>
    <Abstract>Gets an output port. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>hasNext</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a1f24511fe9d78fb82ba42514c83c5174</Anchor>
    <Abstract>See if this node can be followed to other nodes. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>hasPrevious</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a0bb4875e8c6edf49a4c67819be2f2de8</Anchor>
    <Abstract>See if this node can be follow to other nodes. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isCompound</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a5f8bd14ff674f0293b4c3c61be332c4b</Anchor>
    <Abstract>Check if this node is a compound node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isCall</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>ace223e7cc3962091b0497a1c20a178a9</Anchor>
    <Abstract>Check if this node is a call node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>igr::node::SubGraphEntryNode</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>igr.node.SubGraphEntryNode</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_sub_graph_entry_node.html</Path>
    <Abstract>Entry point of a subgraph. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__init__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a597304574e02b2556ce6a4137ec2c78f</Anchor>
    <Abstract>Create a new node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__str__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a89a5287e555372e46085822ec5cfbbad</Anchor>
    <Abstract>Create a printable version of the node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getInputPort</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>aa899fb251fb3bb18b430b6bbc73f4325</Anchor>
    <Abstract>Gets an input port. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getOutputPort</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a1c00ce1173ac404ef762671503122c19</Anchor>
    <Abstract>Gets an output port. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>hasNext</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a1f24511fe9d78fb82ba42514c83c5174</Anchor>
    <Abstract>See if this node can be followed to other nodes. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>hasPrevious</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a0bb4875e8c6edf49a4c67819be2f2de8</Anchor>
    <Abstract>See if this node can be follow to other nodes. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isCompound</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a5f8bd14ff674f0293b4c3c61be332c4b</Anchor>
    <Abstract>Check if this node is a compound node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isCall</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>ace223e7cc3962091b0497a1c20a178a9</Anchor>
    <Abstract>Check if this node is a call node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>igr::node::SubGraphExitNode</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>igr.node.SubGraphExitNode</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_sub_graph_exit_node.html</Path>
    <Abstract>Exit point of a subgraph. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__init__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a597304574e02b2556ce6a4137ec2c78f</Anchor>
    <Abstract>Create a new node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__str__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a89a5287e555372e46085822ec5cfbbad</Anchor>
    <Abstract>Create a printable version of the node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getInputPort</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>aa899fb251fb3bb18b430b6bbc73f4325</Anchor>
    <Abstract>Gets an input port. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getOutputPort</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a1c00ce1173ac404ef762671503122c19</Anchor>
    <Abstract>Gets an output port. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>hasNext</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a1f24511fe9d78fb82ba42514c83c5174</Anchor>
    <Abstract>See if this node can be followed to other nodes. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>hasPrevious</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a0bb4875e8c6edf49a4c67819be2f2de8</Anchor>
    <Abstract>See if this node can be follow to other nodes. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isCompound</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a5f8bd14ff674f0293b4c3c61be332c4b</Anchor>
    <Abstract>Check if this node is a compound node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isCall</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>ace223e7cc3962091b0497a1c20a178a9</Anchor>
    <Abstract>Check if this node is a call node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>igr::node::OperationNode</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>igr.node.OperationNode</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_operation_node.html</Path>
    <Abstract>Operation node. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__init__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a597304574e02b2556ce6a4137ec2c78f</Anchor>
    <Abstract>Create a new node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__str__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a89a5287e555372e46085822ec5cfbbad</Anchor>
    <Abstract>Create a printable version of the node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getInputPort</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>aa899fb251fb3bb18b430b6bbc73f4325</Anchor>
    <Abstract>Gets an input port. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getOutputPort</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a1c00ce1173ac404ef762671503122c19</Anchor>
    <Abstract>Gets an output port. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>hasNext</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a1f24511fe9d78fb82ba42514c83c5174</Anchor>
    <Abstract>See if this node can be followed to other nodes. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>hasPrevious</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a0bb4875e8c6edf49a4c67819be2f2de8</Anchor>
    <Abstract>See if this node can be follow to other nodes. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isCompound</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a5f8bd14ff674f0293b4c3c61be332c4b</Anchor>
    <Abstract>Check if this node is a compound node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isCall</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>ace223e7cc3962091b0497a1c20a178a9</Anchor>
    <Abstract>Check if this node is a call node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>igr::node::CallNode</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>igr.node.CallNode</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_call_node.html</Path>
    <Abstract>Call node. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>bindFunction</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.CallNode</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_call_node.html</Path>
    <Anchor>a769ccc75f32dc1560b70a3fc27394353</Anchor>
    <Abstract>Binds the call node to a certain value. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__init__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a597304574e02b2556ce6a4137ec2c78f</Anchor>
    <Abstract>Create a new node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__str__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a89a5287e555372e46085822ec5cfbbad</Anchor>
    <Abstract>Create a printable version of the node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getInputPort</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>aa899fb251fb3bb18b430b6bbc73f4325</Anchor>
    <Abstract>Gets an input port. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getOutputPort</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a1c00ce1173ac404ef762671503122c19</Anchor>
    <Abstract>Gets an output port. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>hasNext</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a1f24511fe9d78fb82ba42514c83c5174</Anchor>
    <Abstract>See if this node can be followed to other nodes. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>hasPrevious</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a0bb4875e8c6edf49a4c67819be2f2de8</Anchor>
    <Abstract>See if this node can be follow to other nodes. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isCompound</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a5f8bd14ff674f0293b4c3c61be332c4b</Anchor>
    <Abstract>Check if this node is a compound node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isCall</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>ace223e7cc3962091b0497a1c20a178a9</Anchor>
    <Abstract>Check if this node is a call node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>igr::node::CompoundNode</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>igr.node.CompoundNode</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_compound_node.html</Path>
    <Abstract>Compound node. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__init__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a597304574e02b2556ce6a4137ec2c78f</Anchor>
    <Abstract>Create a new node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__str__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a89a5287e555372e46085822ec5cfbbad</Anchor>
    <Abstract>Create a printable version of the node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getInputPort</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>aa899fb251fb3bb18b430b6bbc73f4325</Anchor>
    <Abstract>Gets an input port. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getOutputPort</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a1c00ce1173ac404ef762671503122c19</Anchor>
    <Abstract>Gets an output port. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>hasNext</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a1f24511fe9d78fb82ba42514c83c5174</Anchor>
    <Abstract>See if this node can be followed to other nodes. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>hasPrevious</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a0bb4875e8c6edf49a4c67819be2f2de8</Anchor>
    <Abstract>See if this node can be follow to other nodes. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isCompound</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a5f8bd14ff674f0293b4c3c61be332c4b</Anchor>
    <Abstract>Check if this node is a compound node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isCall</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>ace223e7cc3962091b0497a1c20a178a9</Anchor>
    <Abstract>Check if this node is a call node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>igr::node::ForallCNode</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>igr.node.ForallCNode</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_forall_c_node.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__init__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a597304574e02b2556ce6a4137ec2c78f</Anchor>
    <Abstract>Create a new node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__str__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a89a5287e555372e46085822ec5cfbbad</Anchor>
    <Abstract>Create a printable version of the node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getInputPort</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>aa899fb251fb3bb18b430b6bbc73f4325</Anchor>
    <Abstract>Gets an input port. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getOutputPort</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a1c00ce1173ac404ef762671503122c19</Anchor>
    <Abstract>Gets an output port. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>hasNext</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a1f24511fe9d78fb82ba42514c83c5174</Anchor>
    <Abstract>See if this node can be followed to other nodes. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>hasPrevious</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a0bb4875e8c6edf49a4c67819be2f2de8</Anchor>
    <Abstract>See if this node can be follow to other nodes. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isCompound</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>a5f8bd14ff674f0293b4c3c61be332c4b</Anchor>
    <Abstract>Check if this node is a compound node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isCall</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.node.Node</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1node_1_1_node.html</Path>
    <Anchor>ace223e7cc3962091b0497a1c20a178a9</Anchor>
    <Abstract>Check if this node is a call node. </Abstract>
    <DeclaredIn>node.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>igr::port</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>igr::port</Scope>
    </TokenIdentifier>
    <Path>namespaceigr_1_1port.html</Path>
    <Abstract>Port definitions. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>igr::port::Port</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>igr.port.Port</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1port_1_1_port.html</Path>
    <Abstract>Abstract Port. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__init__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.port.Port</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1port_1_1_port.html</Path>
    <Anchor>a8821b5bef2c723a3aa5fddcb3b44a95e</Anchor>
    <Abstract>Creates a new port for a node and an index. </Abstract>
    <DeclaredIn>port.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__str__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.port.Port</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1port_1_1_port.html</Path>
    <Anchor>a03307f8d0c2742708685d597b680a819</Anchor>
    <Abstract>Create a string version of the port. </Abstract>
    <DeclaredIn>port.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isConnected</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.port.Port</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1port_1_1_port.html</Path>
    <Anchor>a84869c9fd4cd569d2b303aa8b1c4d76c</Anchor>
    <Abstract>See if the port is connected to something. </Abstract>
    <DeclaredIn>port.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>acceptsLiteral</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.port.Port</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1port_1_1_port.html</Path>
    <Anchor>a46f0edf0e624b30fd18c2bc27477756d</Anchor>
    <Abstract>Returns true if this port accepts a literal. </Abstract>
    <DeclaredIn>port.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isPort</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.port.Port</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1port_1_1_port.html</Path>
    <Anchor>aa15affae30bbdbbea3dafd4709feb648</Anchor>
    <Abstract>See if this is a port (mainly for traversal) </Abstract>
    <DeclaredIn>port.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>igr::port::InputPort</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>igr.port.InputPort</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1port_1_1_input_port.html</Path>
    <Abstract>Port that accepts input for a node. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>attach</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.port.InputPort</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1port_1_1_input_port.html</Path>
    <Anchor>a7765fbc72f13568244d07a3084fda8c0</Anchor>
    <Abstract>Attach this port to another port or literal This is an implicit edge representation. </Abstract>
    <DeclaredIn>port.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__init__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.port.Port</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1port_1_1_port.html</Path>
    <Anchor>a8821b5bef2c723a3aa5fddcb3b44a95e</Anchor>
    <Abstract>Creates a new port for a node and an index. </Abstract>
    <DeclaredIn>port.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__str__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.port.Port</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1port_1_1_port.html</Path>
    <Anchor>a03307f8d0c2742708685d597b680a819</Anchor>
    <Abstract>Create a string version of the port. </Abstract>
    <DeclaredIn>port.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isConnected</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.port.Port</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1port_1_1_port.html</Path>
    <Anchor>a84869c9fd4cd569d2b303aa8b1c4d76c</Anchor>
    <Abstract>See if the port is connected to something. </Abstract>
    <DeclaredIn>port.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>acceptsLiteral</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.port.Port</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1port_1_1_port.html</Path>
    <Anchor>a46f0edf0e624b30fd18c2bc27477756d</Anchor>
    <Abstract>Returns true if this port accepts a literal. </Abstract>
    <DeclaredIn>port.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isPort</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.port.Port</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1port_1_1_port.html</Path>
    <Anchor>aa15affae30bbdbbea3dafd4709feb648</Anchor>
    <Abstract>See if this is a port (mainly for traversal) </Abstract>
    <DeclaredIn>port.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>igr::port::OutputPort</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>igr.port.OutputPort</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1port_1_1_output_port.html</Path>
    <Abstract>Exit point of a node. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addTarget</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.port.OutputPort</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1port_1_1_output_port.html</Path>
    <Anchor>aab0ac028ffce0dd49a499eede22d5657</Anchor>
    <Abstract>Add a target to this output port, has to be an input port. </Abstract>
    <DeclaredIn>port.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__init__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.port.Port</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1port_1_1_port.html</Path>
    <Anchor>a8821b5bef2c723a3aa5fddcb3b44a95e</Anchor>
    <Abstract>Creates a new port for a node and an index. </Abstract>
    <DeclaredIn>port.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__str__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.port.Port</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1port_1_1_port.html</Path>
    <Anchor>a03307f8d0c2742708685d597b680a819</Anchor>
    <Abstract>Create a string version of the port. </Abstract>
    <DeclaredIn>port.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isConnected</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.port.Port</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1port_1_1_port.html</Path>
    <Anchor>a84869c9fd4cd569d2b303aa8b1c4d76c</Anchor>
    <Abstract>See if the port is connected to something. </Abstract>
    <DeclaredIn>port.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>acceptsLiteral</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.port.Port</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1port_1_1_port.html</Path>
    <Anchor>a46f0edf0e624b30fd18c2bc27477756d</Anchor>
    <Abstract>Returns true if this port accepts a literal. </Abstract>
    <DeclaredIn>port.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isPort</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.port.Port</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1port_1_1_port.html</Path>
    <Anchor>aa15affae30bbdbbea3dafd4709feb648</Anchor>
    <Abstract>See if this is a port (mainly for traversal) </Abstract>
    <DeclaredIn>port.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>igr::subgraph</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>igr::subgraph</Scope>
    </TokenIdentifier>
    <Path>namespaceigr_1_1subgraph.html</Path>
    <Abstract>SubGraph definitions. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>igr::subgraph::SubGraph</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>igr.subgraph.SubGraph</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1subgraph_1_1_sub_graph.html</Path>
    <Abstract>SubGraph. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__str__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.subgraph.SubGraph</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1subgraph_1_1_sub_graph.html</Path>
    <Anchor>a16615df0720e1ac9d71a30a93aec4f57</Anchor>
    <Abstract>Printable subgraph. </Abstract>
    <DeclaredIn>subgraph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getOutputPort</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.subgraph.SubGraph</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1subgraph_1_1_sub_graph.html</Path>
    <Anchor>a8f0af1f5ac596c81ce41b56ee2da681f</Anchor>
    <Abstract>Get an output port of the subgraph. </Abstract>
    <DeclaredIn>subgraph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getInputPort</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.subgraph.SubGraph</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1subgraph_1_1_sub_graph.html</Path>
    <Anchor>a9b4be1bdeaa5979a8293642fa40b2eb9</Anchor>
    <Abstract>Gets an input port of the subgraph. </Abstract>
    <DeclaredIn>subgraph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>addNode</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>igr.subgraph.SubGraph</Scope>
    </TokenIdentifier>
    <Path>classigr_1_1subgraph_1_1_sub_graph.html</Path>
    <Anchor>a93e4940ef4871e83ac3b3639ffddd486</Anchor>
    <Abstract>Add a node to the node list of the subgraph. </Abstract>
    <DeclaredIn>subgraph.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>log</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>log</Scope>
    </TokenIdentifier>
    <Path>namespacelog.html</Path>
    <Abstract>DVM Logging. </Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>setLock</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>log</Scope>
    </TokenIdentifier>
    <Path>namespacelog.html</Path>
    <Anchor>a19a02b14ef0cf914f9b37cc089b271d4</Anchor>
    <Abstract>Update the lock, this should happen after creating a new process. </Abstract>
    <DeclaredIn>log.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getLock</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>log</Scope>
    </TokenIdentifier>
    <Path>namespacelog.html</Path>
    <Anchor>ab52504cbf016790e76a6c55efd0a0d33</Anchor>
    <Abstract>Get a reference to the loglock. </Abstract>
    <DeclaredIn>log.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>debg</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>log</Scope>
    </TokenIdentifier>
    <Path>namespacelog.html</Path>
    <Anchor>a3437ac04c1bfc9282d9f34d0c3f51594</Anchor>
    <Abstract>Log a debug severity message. </Abstract>
    <DeclaredIn>log.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>info</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>log</Scope>
    </TokenIdentifier>
    <Path>namespacelog.html</Path>
    <Anchor>a8e3ea60d7c7d7695350241b29425b4f9</Anchor>
    <Abstract>Log an information message. </Abstract>
    <DeclaredIn>log.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>warn</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>log</Scope>
    </TokenIdentifier>
    <Path>namespacelog.html</Path>
    <Anchor>a3447b086820a8dcc437791113d4d2402</Anchor>
    <Abstract>Log a warning message. </Abstract>
    <DeclaredIn>log.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>err</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>log</Scope>
    </TokenIdentifier>
    <Path>namespacelog.html</Path>
    <Anchor>acecba27de46867486220dade7ba9e4a2</Anchor>
    <Abstract>Log an error message. </Abstract>
    <DeclaredIn>log.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__severities__</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>log</Scope>
    </TokenIdentifier>
    <Path>namespacelog.html</Path>
    <Anchor>a1cc21838b30cf8f8370a7eb503651836</Anchor>
    <Abstract>Defines the various logging levels. </Abstract>
    <DeclaredIn>log.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__logLock__</Name>
      <APILanguage>python</APILanguage>
      <Type>data</Type>
      <Scope>log</Scope>
    </TokenIdentifier>
    <Path>namespacelog.html</Path>
    <Anchor>a251cea60e4e45c72304197364f745846</Anchor>
    <Abstract>The log that controls access to the output. </Abstract>
    <DeclaredIn>log.py</DeclaredIn>
  </Token>
</Tokens>
