# IF1 

This page serves as a basic introduction to the IF1 language.
The information on this page is based on the paper: `IF1 - An Intermediate Form for Applicative Languages. (Stephen Skedzielewski 1985)`

[TOC]

# Basics # {#Basics}

## Graphs in IF1 ## {#Graphs}

IF1 uses directed, acyclic graphs, these graphs have a few components.

* IF1 nodes are operations.
	* a node can have an arbitrary amount of in -and outputs.
	* IF1 defines over 50 nodes, that is, "native" operations.
	* The in -and output of a node happens through **ports**, which are numbered indicators of in and output locations
	* Not every node has a predefined amount of ports.
* Edges represent data paths between nodes.
	* Edges carry **type information**
		* Not mandatory
		* Can describe user-defined types and built-in types.
	* A special edge exists to describe literal constants.
		* Don't contain a source port
		* Contain the text of a literal as a string.
* Graph boundaries surround groups of nodes and edges.

IF1 can also contain comments.

## IF1 form ## {#Form}

IF1 instructions are delimited by newlines. The first character after a newline determines the instruction the line represents, the rest of the line consists of a number of whitespace separated fields, the amount of which depends on that specific instruction. Any extra text listed after the fields is considered to be a comment, so are lines that start with C. For more information about comments, look into [appendix A](#Comments).

The following table lists the different instructions. 

Character | Represents | Syntax 
----------| -----------|-------
T         | type   						| `T label type_code basic_code `
E 		  | edge 						| `E source_node port destination_node port type `
L 		  | literal						| `L destination_node port type string `
G 		  | subgraph of a compound node | `G integer `
G 		  | local function graph 		| `G type_reference "name" `
X 		  | global function graph 		| `X type_reference "name" `
L 		  | imported function   		| `L type_reference "name" `
N 		  | simple node   				| `N label operation `
{		  | compound node 				| `{compound definition (contains newlines)} label operation integers `




# Appendix A: Comments {#Comments}

2 main types of comments exist in IF1, stamps and pragmas, stamps are comments that occupy an entire line that starts with `C$`, pragmas are comments that are added after the fields of a line.

## Stamps ## {#Stamps}

Stamps are used to mark some processing that has been done to a file, a few stamp type exists. A stamp line has the following syntax: `C$ stamp_type info`.
The following table provides an overview of the different stamp types.

Character | Meaning
----------|--------
A | Array update analysis
C | Structure checker
D | Order nodes using data dependencies
E | Common subexpression information 
F | Frontend
L | L Loop invariant removal
O | Add offsets for use by the interpreter
P | Partitioning analysis
S | Stream analysis
V | Vector analysis

## Pragmas ## {#Pragmas}

Pragmas are used to add additional information to an instruction. Currently, 2 types of pragmas exist, pragmas that are generated by the compiler, and pragmas that are added after analyzing. Multiple pragmas can be added after a single instruction. Pragmas are terminated by a whitespace character. 

Pragmas have the following syntax: `%<id>=<anything>,<otheranything> %<otherid>=<anything>`

The following table provides an overview of the meaning of different pragmas. The type column indicates the type of pragma; C indicates a compiler-generated pragma, while A indicates a pragma generated by analyzing.

Character | Type | Meaning
----------|------|---------
bd | C | bounds
na | C | name
sl | C | source line
op | C | op number with line of source
ar | A | size of activation record needed
lz | A | edge carries a value that must be demanded
mk | A | mark this edge by reference (%mk=r) or by value (%mk=v)
of | A | offset in activation record
st | A | style of memory allocation (%st=p for pointer, %st=c for contiguous)
xy | A | position for node in graphic output
